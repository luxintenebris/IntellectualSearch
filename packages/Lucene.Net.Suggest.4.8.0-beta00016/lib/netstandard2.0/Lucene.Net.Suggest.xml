<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net.Suggest</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Search.Spell.CombineSuggestion">
            <summary>
            <para>A suggestion generated by combining one or more original query terms</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.CombineSuggestion.#ctor(Lucene.Net.Search.Spell.SuggestWord,System.Int32[])">
            <summary>
            Creates a new CombineSuggestion from a <code>suggestion</code> and
            an array of term ids (referencing the indexes to the original terms that
            form this combined suggestion)
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.CombineSuggestion.OriginalTermIndexes">
            <summary>
            The indexes from the passed-in array of terms used to make this word combination
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.CombineSuggestion.Suggestion">
            <summary>
            The word combination suggestion
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.IDictionary">
            <summary>
            A simple interface representing a Dictionary. A Dictionary
            here is a list of entries, where every entry consists of
            term, weight and payload.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.IDictionary.GetEntryEnumerator">
            <summary>
            Returns an enumerator over all the entries.</summary>
            <returns> Enumerator </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spell.DirectSpellChecker">
            <summary>
            Simple automaton-based spellchecker.
            <para>
            Candidates are presented directly from the term dictionary, based on
            Levenshtein distance. This is an alternative to <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/>
            if you are using an edit-distance-like metric such as Levenshtein
            or <see cref="T:Lucene.Net.Search.Spell.JaroWinklerDistance"/>.
            </para>
            <para>
            A practical benefit of this spellchecker is that it requires no additional
            datastructures (neither in RAM nor on disk) to do its work.
            
            </para>
            </summary>
            <seealso cref="T:Lucene.Net.Util.Automaton.LevenshteinAutomata"/>
            <seealso cref="T:Lucene.Net.Search.FuzzyTermsEnum"/>
            
            @lucene.experimental
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.INTERNAL_LEVENSHTEIN">
            <summary>
            The default StringDistance, Damerau-Levenshtein distance implemented internally
             via <see cref="T:Lucene.Net.Util.Automaton.LevenshteinAutomata"/>.
             <para>
             Note: this is the fastest distance metric, because Damerau-Levenshtein is used
             to draw candidates from the term dictionary: this just re-uses the scoring.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.maxEdits">
            <summary>
            maximum edit distance for candidate terms </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.minPrefix">
            <summary>
            minimum prefix for candidate terms </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.maxInspections">
            <summary>
            maximum number of top-N inspections per suggestion </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.accuracy">
            <summary>
            minimum accuracy for a term to match </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.thresholdFrequency">
            <summary>
            value in [0..1] (or absolute number >=1) representing the minimum
            number of documents (of the total) where a term should appear. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.minQueryLength">
            <summary>
            minimum length of a query word to return suggestions </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.maxQueryFrequency">
            <summary>
            value in [0..1] (or absolute number >=1) representing the maximum
             number of documents (of the total) a query term can appear in to
             be corrected. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.lowerCaseTerms">
            <summary>
            true if the spellchecker should lowercase terms </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.comparer">
            <summary>
            the comparer to use </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.distance">
            <summary>
            the string distance to use </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.DirectSpellChecker.lowerCaseTermsCulture">
            <summary>
            The culture to use for lowercasing terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.#ctor">
            <summary>
            Creates a DirectSpellChecker with default configuration values 
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.MaxEdits">
            <summary>
            Gets or sets the maximum number of Levenshtein edit-distances to draw
            candidate terms from.This value can be 1 or 2. The default is 2.
            
            Note: a large number of spelling errors occur with an edit distance
            of 1, by setting this value to 1 you can increase both performance
            and precision at the cost of recall.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.MinPrefix">
            <summary>
            Gets or sets the minimal number of characters that must match exactly.
            
            This can improve both performance and accuracy of results, 
            as misspellings are commonly not the first character.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.MaxInspections">
            <summary>
            Get the maximum number of top-N inspections per suggestion.
            
            Increasing this number can improve the accuracy of results, at the cost 
            of performance.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.Accuracy">
            <summary>
            Gets or sets the minimal accuracy required (default: 0.5f) from a StringDistance 
            for a suggestion match.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ThresholdFrequency">
            <summary>
            Gets or sets the minimal threshold of documents a term must appear for a match.
            <para/>
            This can improve quality by only suggesting high-frequency terms. Note that
            very high values might decrease performance slightly, by forcing the spellchecker
            to draw more candidates from the term dictionary, but a practical value such
            as <c>1</c> can be very useful towards improving quality.
            <para/>
            This can be specified as a relative percentage of documents such as 0.5f,
            or it can be specified as an absolute whole document frequency, such as 4f.
            Absolute document frequencies may not be fractional.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.MinQueryLength">
            <summary>
            Gets or sets the minimum length of a query term (default: 4) needed to return suggestions.
            <para/>
            Very short query terms will often cause only bad suggestions with any distance
            metric.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.MaxQueryFrequency">
            <summary>
            Gets or sets the maximum threshold (default: 0.01f) of documents a query term can 
            appear in order to provide suggestions.
            <para/>
            Very high-frequency terms are typically spelled correctly. Additionally,
            this can increase performance as it will do no work for the common case
            of correctly-spelled input terms.
            <para/>
            This can be specified as a relative percentage of documents such as 0.5f,
            or it can be specified as an absolute whole document frequency, such as 4f.
            Absolute document frequencies may not be fractional.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.LowerCaseTerms">
            <summary>
            True if the spellchecker should lowercase terms (default: true)
            <para/>
            This is a convenience method, if your index field has more complicated
            analysis (such as StandardTokenizer removing punctuation), its probably
            better to turn this off, and instead run your query terms through your
            Analyzer first.
            <para/>
            If this option is not on, case differences count as an edit!
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.LowerCaseTermsCulture">
            <summary>
            Gets or sets the culture to use for lowercasing terms.
            Set to <c>null</c> (the default) to use <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.Comparer">
            <summary>
            Gets or sets the comparer for sorting suggestions.
            The default is <see cref="F:Lucene.Net.Search.Spell.SuggestWordQueue.DEFAULT_COMPARER"/> 
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.Distance">
            <summary>
            Gets or sets the string distance metric.
            The default is <see cref="F:Lucene.Net.Search.Spell.DirectSpellChecker.INTERNAL_LEVENSHTEIN"/>.
            <para/>
            Note: because this spellchecker draws its candidates from the term
            dictionary using Damerau-Levenshtein, it works best with an edit-distance-like
            string metric. If you use a different metric than the default,
            you might want to consider increasing <see cref="P:Lucene.Net.Search.Spell.DirectSpellChecker.MaxInspections"/>
            to draw more candidates for your metric to rank. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode)"/>
                  SuggestSimilar(term, numSug, ir, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/>
                  SuggestSimilar(term, numSug, ir, suggestMode, this.accuracy)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode,System.Single)">
            <summary>
            Suggest similar words.
            
            <para>
            Unlike <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/>, the similarity used to fetch the most
            relevant terms is an edit distance, therefore typically a low value
            for numSug will work very well.
            </para>
            </summary>
            <param name="term"> Term you want to spell check on </param>
            <param name="numSug"> the maximum number of suggested words </param>
            <param name="ir"> IndexReader to find terms from </param>
            <param name="suggestMode"> specifies when to return suggested words </param>
            <param name="accuracy"> return only suggested words that match with this similarity </param>
            <returns> sorted list of the suggested words according to the comparer </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.SuggestSimilar(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,System.Int32,System.Int32,System.Single,Lucene.Net.Util.CharsRef)">
            <summary>
            Provide spelling corrections based on several parameters.
            </summary>
            <param name="term"> The term to suggest spelling corrections for </param>
            <param name="numSug"> The maximum number of spelling corrections </param>
            <param name="ir"> The index reader to fetch the candidate spelling corrections from </param>
            <param name="docfreq"> The minimum document frequency a potential suggestion need to have in order to be included </param>
            <param name="editDistance"> The maximum edit distance candidates are allowed to have </param>
            <param name="accuracy"> The minimum accuracy a suggested spelling correction needs to have in order to be included </param>
            <param name="spare"> a chars scratch </param>
            <returns> a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order. </returns>
            <exception cref="T:System.IO.IOException"> If I/O related errors occur </exception>
        </member>
        <member name="T:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm">
            <summary>
            Holds a spelling correction for internal usage inside <see cref="T:Lucene.Net.Search.Spell.DirectSpellChecker"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.Term">
            <summary>
            The actual spellcheck correction.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.Boost">
            <summary>
            The boost representing the similarity from the FuzzyTermsEnum (internal similarity score)
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.Docfreq">
            <summary>
            The df of the spellcheck correction.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.TermAsString">
            <summary>
            The spellcheck correction represented as string, can be <code>null</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.Score">
            <summary>
            The similarity score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.DirectSpellChecker.ScoreTerm.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.HighFrequencyDictionary">
            <summary>
            HighFrequencyDictionary: terms taken from the given field
            of a Lucene index, which appear in a number of documents
            above a given threshold.
            
            Threshold is a value in [0..1] representing the minimum
            number of documents (of the total) where a term should appear.
            
            Based on <see cref="T:Lucene.Net.Search.Spell.LuceneDictionary"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.HighFrequencyDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,System.Single)">
            <summary>
            Creates a new Dictionary, pulling source terms from
            the specified <code>field</code> in the provided <code>reader</code>.
            <para>
            Terms appearing in less than <code>thresh</code> percentage of documents
            will be excluded.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.JaroWinklerDistance">
            <summary>
            Similarity measure for short strings such as person names.
            See <a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.JaroWinklerDistance.#ctor">
            <summary>
            Creates a new distance metric with the default threshold
            for the Jaro Winkler bonus (0.7) </summary>
            <seealso cref="P:Lucene.Net.Search.Spell.JaroWinklerDistance.Threshold"/>
        </member>
        <member name="P:Lucene.Net.Search.Spell.JaroWinklerDistance.Threshold">
            <summary>
            Gets or sets the threshold used to determine when Winkler bonus should be used.
            The default value is 0.7. Set to a negative value to get the Jaro distance. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.LevensteinDistance">
            <summary>
            Levenstein edit distance class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.LevensteinDistance.#ctor">
            <summary>
            Optimized to run a bit faster than the static GetDistance().
            In one benchmark times were 5.3sec using ctr vs 8.5sec w/ static method, thus 37% faster.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.LuceneDictionary">
            <summary>
            Lucene Dictionary: terms taken from the given field
            of a Lucene index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.LuceneDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Creates a new Dictionary, pulling source terms from
            the specified <code>field</code> in the provided <code>reader</code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.LuceneLevenshteinDistance">
            <summary>
             Damerau-Levenshtein (optimal string alignment) implemented in a consistent 
             way as Lucene's FuzzyTermsEnum with the transpositions option enabled.
             
             Notes:
             <list type="bullet">
               <item><description> This metric treats full unicode codepoints as characters</description></item>
               <item><description> This metric scales raw edit distances into a floating point score
                    based upon the shortest of the two terms</description></item>
               <item><description> Transpositions of two adjacent codepoints are treated as primitive 
                    edits.</description></item>
               <item><description> Edits are applied in parallel: for example, "ab" and "bca" have 
                    distance 3.</description></item>
             </list>
             
             NOTE: this class is not particularly efficient. It is only intended
             for merging results from multiple DirectSpellCheckers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.LuceneLevenshteinDistance.#ctor">
            <summary>
            Creates a new comparer, mimicing the behavior of Lucene's internal
            edit distance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.LuceneLevenshteinDistance.ToInt32sRef(System.String)">
            <summary>
            NOTE: This was toIntsRef() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.NGramDistance">
            <summary>
            N-Gram version of edit distance based on paper by Grzegorz Kondrak, 
            "N-gram similarity and distance". Proceedings of the Twelfth International 
            Conference on String Processing and Information Retrieval (SPIRE 2005), pp. 115-126, 
            Buenos Aires, Argentina, November 2005. 
            <a href="http://www.cs.ualberta.ca/~kondrak/papers/spire05.pdf">http://www.cs.ualberta.ca/~kondrak/papers/spire05.pdf</a>
            
            This implementation uses the position-based optimization to compute partial
            matches of n-gram sub-strings and adds a null-character prefix of size n-1 
            so that the first character is contained in the same number of n-grams as 
            a middle character.  Null-character prefix matches are discounted so that 
            strings with no matching characters will return a distance of 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.NGramDistance.#ctor(System.Int32)">
            <summary>
            Creates an N-Gram distance measure using n-grams of the specified size. </summary>
            <param name="size"> The size of the n-gram to be used to compute the string distance. </param>
        </member>
        <member name="M:Lucene.Net.Search.Spell.NGramDistance.#ctor">
            <summary>
            Creates an N-Gram distance measure using n-grams of size 2.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.PlainTextDictionary">
            <summary>
            Dictionary represented by a text file.
            
            <para/>Format allowed: 1 word per line:<para/>
            word1<para/>
            word2<para/>
            word3<para/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.PlainTextDictionary.#ctor(System.IO.FileInfo)">
            <summary>
            Creates a dictionary based on a File.
            <para>
            NOTE: content is treated as UTF-8
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.PlainTextDictionary.#ctor(System.IO.Stream)">
            <summary>
            Creates a dictionary based on an inputstream.
            <para>
            NOTE: content is treated as UTF-8
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.PlainTextDictionary.#ctor(System.IO.TextReader)">
            <summary>
            Creates a dictionary based on a reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SpellChecker">
            <summary>
            <para>
              Spell Checker class  (Main class) <br/>
             (initially inspired by the David Spencer code).
            </para>
            
            <para>Example Usage (C#):
            
            <code>
             SpellChecker spellchecker = new SpellChecker(spellIndexDirectory);
             // To index a field of a user index:
             spellchecker.IndexDictionary(new LuceneDictionary(my_lucene_reader, a_field));
             // To index a file containing words:
             spellchecker.IndexDictionary(new PlainTextDictionary(new FileInfo("myfile.txt")));
             string[] suggestions = spellchecker.SuggestSimilar("misspelt", 5);
            </code>
            
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.DEFAULT_ACCURACY">
            <summary>
            The default minimum score to use, if not specified by setting <see cref="P:Lucene.Net.Search.Spell.SpellChecker.Accuracy"/>
            or overriding with <see cref="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/> .
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.F_WORD">
            <summary>
            Field name for each word in the ngram index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.spellIndex">
            <summary>
            the spell index
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.bStart">
            <summary>
            Boost value for start and end grams
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.searcherLock">
            <summary>
            this locks all modifications to the current searcher.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SpellChecker.modifyCurrentIndexLock">
            <summary>
            this lock synchronizes all possible modifications to the
            current index directory.It should not be possible to try modifying
            the same index concurrently.Note: Do not acquire the searcher lock
            before acquiring this lock!
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Search.Spell.IStringDistance)">
            <summary>
            Use the given directory as a spell checker index. The directory
            is created if it doesn't exist yet. </summary>
            <param name="spellIndex"> the spell index directory </param>
            <param name="sd"> the <see cref="P:Lucene.Net.Search.Spell.SpellChecker.StringDistance"/> measurement to use </param>
            <exception cref="T:System.IO.IOException"> if Spellchecker can not open the directory </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Use the given directory as a spell checker index with a
            <see cref="T:Lucene.Net.Search.Spell.LevensteinDistance"/> as the default <see cref="T:StringDistance"/>. The
            directory is created if it doesn't exist yet.
            </summary>
            <param name="spellIndex">
                     the spell index directory </param>
            <exception cref="T:System.IO.IOException">
                      if spellchecker can not open the directory </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Search.Spell.IStringDistance,System.Collections.Generic.IComparer{Lucene.Net.Search.Spell.SuggestWord})">
            <summary>
            Use the given directory as a spell checker index with the given <see cref="T:Lucene.Net.Search.Spell.IStringDistance"/> measure
            and the given <see cref="T:System.Collections.Generic.IComparer`1"/> for sorting the results. </summary>
            <param name="spellIndex"> The spelling index </param>
            <param name="sd"> The distance </param>
            <param name="comparer"> The comparer </param>
            <exception cref="T:System.IO.IOException"> if there is a problem opening the index </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.SetSpellIndex(Lucene.Net.Store.Directory)">
            <summary>
            Sets a different index as the spell checker index or re-open
            the existing index if <code>spellIndex</code> is the same value
            as given in the constructor. </summary>
            <param name="spellIndexDir"> the spell directory to use </param>
            <exception cref="T:System.ObjectDisposedException"> if the Spellchecker is already closed </exception>
            <exception cref="T:System.IO.IOException"> if spellchecker can not open the directory </exception>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SpellChecker.Comparer">
            <summary>
            Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1"/> for the <see cref="T:Lucene.Net.Search.Spell.SuggestWordQueue"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SpellChecker.StringDistance">
            <summary>
            Gets or sets the <see cref="T:Lucene.Net.Search.Spell.IStringDistance"/> implementation for this
            <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> instance.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SpellChecker.Accuracy">
            <summary>
            Gets or sets the accuracy (minimum score) to be used, unless overridden in 
            <see cref="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/>, 
            to decide whether a suggestion is included or not.
            Sets the accuracy 0 &lt; minScore &lt; 1; default <see cref="F:Lucene.Net.Search.Spell.SpellChecker.DEFAULT_ACCURACY"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32)">
            <summary>
            Suggest similar words.
            <para>
            As the Lucene similarity that is used to fetch the most relevant n-grammed terms
            is not the same as the edit distance strategy used to calculate the best
            matching spell-checked word from the hits that Lucene found, one usually has
            to retrieve a couple of numSug's in order to get the true best match.
            </para>
            <para>
            I.e. if numSug == 1, don't count on that suggestion being the best one.
            Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
            </para>
            </summary>
            <param name="word"> the word you want a spell check done on </param>
            <param name="numSug"> the number of suggested words </param>
            <exception cref="T:System.IO.IOException"> if the underlying index throws an <see cref="T:System.IO.IOException"/> </exception>
            <exception cref="T:System.ObjectDisposedException"> if the Spellchecker is already disposed </exception>
            <returns>string[] the sorted list of the suggest words with these 2 criteria:
            first criteria: the edit distance, second criteria (only if restricted mode): the popularity
            of the suggest words in the field of the user index</returns>
            <seealso cref="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,System.Single)">
            <summary>
            Suggest similar words.
            <para>
            As the Lucene similarity that is used to fetch the most relevant n-grammed terms
            is not the same as the edit distance strategy used to calculate the best
            matching spell-checked word from the hits that Lucene found, one usually has
            to retrieve a couple of numSug's in order to get the true best match.
            </para>
            <para>
            I.e. if numSug == 1, don't count on that suggestion being the best one.
            Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
            </para>
            </summary>
            <param name="word"> the word you want a spell check done on </param>
            <param name="numSug"> the number of suggested words </param>
            <param name="accuracy"> The minimum score a suggestion must have in order to qualify for inclusion in the results </param>
            <exception cref="T:System.IO.IOException"> if the underlying index throws an <see cref="T:System.IO.IOException"/> </exception>
            <exception cref="T:System.ObjectDisposedException"> if the Spellchecker is already disposed </exception>
            <returns>string[] the sorted list of the suggest words with these 2 criteria:
            first criteria: the edit distance, second criteria (only if restricted mode): the popularity
            of the suggest words in the field of the user index</returns>
            <seealso cref="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)"/>
                  SuggestSimilar(word, numSug, ir, suggestMode, field, this.accuracy)
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.SuggestSimilar(System.String,System.Int32,Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.Spell.SuggestMode,System.Single)">
            <summary>
            Suggest similar words (optionally restricted to a field of an index).
            <para>
            As the Lucene similarity that is used to fetch the most relevant n-grammed terms
            is not the same as the edit distance strategy used to calculate the best
            matching spell-checked word from the hits that Lucene found, one usually has
            to retrieve a couple of numSug's in order to get the true best match.
            </para>
            <para>
            I.e. if numSug == 1, don't count on that suggestion being the best one.
            Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
            </para>
            </summary>
            <param name="word"> the word you want a spell check done on </param>
            <param name="numSug"> the number of suggested words </param>
            <param name="ir"> the indexReader of the user index (can be null see field param) </param>
            <param name="field"> the field of the user index: if field is not null, the suggested
            words are restricted to the words present in this field. </param>
            <param name="suggestMode"> 
            (NOTE: if indexReader==null and/or field==null, then this is overridden with SuggestMode.SUGGEST_ALWAYS) </param>
            <param name="accuracy"> The minimum score a suggestion must have in order to qualify for inclusion in the results </param>
            <exception cref="T:System.IO.IOException"> if the underlying index throws an <see cref="T:System.IO.IOException"/> </exception>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is already disposed </exception>
            <returns> string[] the sorted list of the suggest words with these 2 criteria:
            first criteria: the edit distance, second criteria (only if restricted mode): the popularity
            of the suggest words in the field of the user index
             </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.Add(Lucene.Net.Search.BooleanQuery,System.String,System.String,System.Single)">
            <summary>
            Add a clause to a boolean query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.Add(Lucene.Net.Search.BooleanQuery,System.String,System.String)">
            <summary>
            Add a clause to a boolean query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.FormGrams(System.String,System.Int32)">
            <summary>
            Form all ngrams for a given word. </summary>
            <param name="text"> the word to parse </param>
            <param name="ng"> the ngram length e.g. 3 </param>
            <returns> an array of all ngrams in the word and note that duplicates are not removed </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.ClearIndex">
            <summary>
            Removes all terms from the spell check index. </summary>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <exception cref="T:System.ObjectDisposedException"> if the Spellchecker is already closed </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.Exist(System.String)">
            <summary>
            Check whether the word exists in the index. </summary>
            <param name="word"> word to check </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is already disposed </exception>
            <returns> true if the word exists in the index </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.IndexDictionary(Lucene.Net.Search.Spell.IDictionary,Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Indexes the data from the given <see cref="T:Lucene.Net.Search.Spell.IDictionary"/>. </summary>
            <param name="dict"> Dictionary to index </param>
            <param name="config"> <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> to use </param>
            <param name="fullMerge"> whether or not the spellcheck index should be fully merged </param>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is already disposed </exception>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.Dispose">
            <summary>
            Dispose the underlying <see cref="T:Lucene.Net.Search.IndexSearcher"/> used by this <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/>. </summary>
            <exception cref="T:System.IO.IOException"> if the close operation causes an <see cref="T:System.IO.IOException"/> </exception>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is already disposed </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.Dispose(System.Boolean)">
            <summary>
            Releases resources used by the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> and
            if overridden in a derived class, optionally releases unmanaged resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources;
            <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SpellChecker.CreateSearcher(Lucene.Net.Store.Directory)">
            <summary>
            Creates a new read-only IndexSearcher </summary>
            <param name="dir"> the directory used to open the searcher </param>
            <returns> a new read-only IndexSearcher </returns>
            <exception cref="T:System.IO.IOException"> f there is a low-level IO error </exception>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SpellChecker.IsDisposed">
            <summary>
            Returns <c>true</c> if and only if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is
            disposed, otherwise <c>false</c>.
            </summary>
            <returns> <c>true</c> if and only if the <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> is
                    disposed, otherwise <c>false</c>. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spell.IStringDistance">
            <summary>
            Interface for string distances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.IStringDistance.GetDistance(System.String,System.String)">
            <summary>
            Returns a float between 0 and 1 based on how similar the specified strings are to one another.  
            Returning a value of 1 means the specified strings are identical and 0 means the
            string are maximally different. </summary>
            <param name="s1"> The first string. </param>
            <param name="s2"> The second string. </param>
            <returns> a float between 0 and 1 based on how similar the specified strings are to one another. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SuggestMode">
            <summary>
            Set of strategies for suggesting related terms
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX">
            <summary>
            Generate suggestions only for terms not in the index (default)
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_MORE_POPULAR">
            <summary>
            Return only suggested words that are as frequent or more frequent than the
            searched word
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_ALWAYS">
            <summary>
            Always attempt to offer suggestions (however, other parameters may limit
            suggestions. For example, see
            <see cref="P:Lucene.Net.Search.Spell.DirectSpellChecker.MaxQueryFrequency"/> ).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SuggestWord">
            <summary>
            SuggestWord, used in suggestSimilar method in <see cref="T:Lucene.Net.Search.Spell.SpellChecker"/> class.
            <p/>
            Default sort is first by score, then by frequency.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SuggestWord.#ctor">
            <summary>
            Creates a new empty suggestion with null text.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SuggestWord.Score">
            <summary>
            the score of the word
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SuggestWord.Freq">
            <summary>
            The freq of the word
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.SuggestWord.String">
            <summary>
            the suggested word
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SuggestWordFrequencyComparer">
            <summary>
             Frequency first, then score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SuggestWordFrequencyComparer.#ctor">
            <summary>
            Creates a new comparer that will compare by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.Freq"/>,
            then by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.Score"/>, then by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SuggestWordQueue">
            <summary>
            Sorts SuggestWord instances
            </summary>
            <seealso cref="T:Lucene.Net.Search.Spell.SuggestWordScoreComparer"/>
            <seealso cref="T:Lucene.Net.Search.Spell.SuggestWordFrequencyComparer"/>
        </member>
        <member name="F:Lucene.Net.Search.Spell.SuggestWordQueue.DEFAULT_COMPARER">
            <summary>
            Default comparer: score then frequency. </summary>
            <seealso cref="T:Lucene.Net.Search.Spell.SuggestWordScoreComparer"/>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SuggestWordQueue.#ctor(System.Int32)">
            <summary>
            Use the <see cref="F:Lucene.Net.Search.Spell.SuggestWordQueue.DEFAULT_COMPARER"/> </summary>
            <param name="size"> The size of the queue </param>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SuggestWordQueue.#ctor(System.Int32,System.Collections.Generic.IComparer{Lucene.Net.Search.Spell.SuggestWord})">
            <summary>
            Specify the size of the queue and the comparer to use for sorting. </summary>
            <param name="size"> The size </param>
            <param name="comparer"> The comparer. </param>
        </member>
        <member name="T:Lucene.Net.Search.Spell.SuggestWordScoreComparer">
            <summary>
            Score first, then frequency
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.SuggestWordScoreComparer.#ctor">
            <summary>
            Creates a new comparer that will compare by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.Score"/>,
            then by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.Freq"/>, then by <see cref="P:Lucene.Net.Search.Spell.SuggestWord.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.ITermFreqEnumerator">
            <summary>
            Interface for enumerating term,weight pairs.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.ITermFreqEnumerator.Weight">
            <summary>
            Gets the term's weight, higher numbers mean better suggestions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.TermFreqEnumeratorWrapper">
            <summary>
            Wraps a <see cref="T:Lucene.Net.Util.BytesRefEnumerator"/> as a <see cref="T:Lucene.Net.Search.Spell.ITermFreqEnumerator"/>, with all weights
            set to <c>1</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.TermFreqEnumeratorWrapper.#ctor(Lucene.Net.Util.IBytesRefEnumerator)">
            <summary>
            Creates a new wrapper, wrapping the specified iterator and 
            specifying a weight value of <code>1</code> for all terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spell.WordBreakSpellChecker">
            <summary>
            <para>
            A spell checker whose sole function is to offer suggestions by combining
            multiple terms into one word and/or breaking terms into multiple words.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.WordBreakSpellChecker.SEPARATOR_TERM">
            <summary>
            Term that can be used to prohibit adjacent terms from being combined </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.WordBreakSpellChecker.#ctor">
            <summary>
            Creates a new spellchecker with default configuration values </summary>
            <seealso cref="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxChanges"/>
            <seealso cref="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxCombineWordLength"/>
            <seealso cref="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxEvaluations"/>
            <seealso cref="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MinBreakWordLength"/>
            <seealso cref="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MinSuggestionFrequency"/>
        </member>
        <member name="T:Lucene.Net.Search.Spell.WordBreakSpellChecker.BreakSuggestionSortMethod">
            <summary>
            Determines the order to list word break suggestions
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.WordBreakSpellChecker.BreakSuggestionSortMethod.NUM_CHANGES_THEN_SUMMED_FREQUENCY">
            <summary>
            <para>
            Sort by Number of word breaks, then by the Sum of all the component
            term's frequencies
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spell.WordBreakSpellChecker.BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY">
            <summary>
            <para>
            Sort by Number of word breaks, then by the Maximum of all the component
            term's frequencies
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spell.WordBreakSpellChecker.SuggestWordBreaks(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode,Lucene.Net.Search.Spell.WordBreakSpellChecker.BreakSuggestionSortMethod)">
            <summary>
            Generate suggestions by breaking the passed-in term into multiple words.
            The scores returned are equal to the number of word breaks needed so a
            lower score is generally preferred over a higher score.
            </summary>
            <param name="suggestMode">
                     - default = <see cref="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX"/> </param>
            <param name="sortMethod">
                     - default = <see cref="F:Lucene.Net.Search.Spell.WordBreakSpellChecker.BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY"/> </param>
            <returns> one or more arrays of words formed by breaking up the original term </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Spell.WordBreakSpellChecker.SuggestWordCombinations(Lucene.Net.Index.Term[],System.Int32,Lucene.Net.Index.IndexReader,Lucene.Net.Search.Spell.SuggestMode)">
            <summary>
            <para>
            Generate suggestions by combining one or more of the passed-in terms into
            single words. The returned <see cref="T:Lucene.Net.Search.Spell.CombineSuggestion"/> contains both a
            <see cref="T:Lucene.Net.Search.Spell.SuggestWord"/> and also an array detailing which passed-in terms were
            involved in creating this combination. The scores returned are equal to the
            number of word combinations needed, also one less than the length of the
            array <see cref="P:Lucene.Net.Search.Spell.CombineSuggestion.OriginalTermIndexes"/>. Generally, a
            suggestion with a lower score is preferred over a higher score.
            </para>
            <para>
            To prevent two adjacent terms from being combined (for instance, if one is
            mandatory and the other is prohibited), separate the two terms with
            <see cref="F:Lucene.Net.Search.Spell.WordBreakSpellChecker.SEPARATOR_TERM"/>
            </para>
            <para>
            When suggestMode equals <see cref="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX"/>, each
            suggestion will include at least one term not in the index.
            </para>
            <para>
            When suggestMode equals <see cref="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_MORE_POPULAR"/>, each
            suggestion will have the same, or better frequency than the most-popular
            included term.
            </para>
            </summary>
            <returns> an array of words generated by combining original terms </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MinSuggestionFrequency">
            <summary>
            Gets or sets the minimum frequency a term must have to be 
            included as part of a suggestion. Default=1 Not applicable when used with
            <see cref="F:Lucene.Net.Search.Spell.SuggestMode.SUGGEST_MORE_POPULAR"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxCombineWordLength">
            <summary>
            Gets or sets the maximum length of a suggestion made 
            by combining 1 or more original terms. Default=20.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MinBreakWordLength">
            <summary>
            Gets or sets the minimum length to break words down to. Default=1.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxChanges">
            <summary>
            Gets or sets the maximum numbers of changes (word breaks or combinations) to make 
            on the original term(s). Default=1.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spell.WordBreakSpellChecker.MaxEvaluations">
            <summary>
            Gets or sets the maximum number of word combinations to evaluate. Default=1000. A higher
            value might improve result quality. A lower value might improve performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester">
            <summary>
            Analyzes the input text and then suggests matches based
             on prefix matches to any tokens in the indexed text.
             This also highlights the tokens that match.
            
             <para>This suggester supports payloads.  Matches are sorted only
             by the suggest weight; it would be nice to support
             blended score + weight sort in the future.  This means
             this suggester best applies when there is a strong
             a-priori ranking of all the suggestions.
            
            </para>
             <para>This suggester supports contexts, however the
             contexts must be valid utf8 (arbitrary binary terms will
             not work).
            
            @lucene.experimental 
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.TEXT_FIELD_NAME">
            <summary>
            Field name used for the indexed text. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.EXACT_TEXT_FIELD_NAME">
            <summary>
            Field name used for the indexed text, as a
            <see cref="T:Lucene.Net.Documents.StringField"/>, for exact lookup. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.CONTEXTS_FIELD_NAME">
            <summary>
            Field name used for the indexed context, as a
            <see cref="T:Lucene.Net.Documents.StringField"/> and a <see cref="T:Lucene.Net.Documents.SortedSetDocValuesField"/>, for filtering. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.m_queryAnalyzer">
            <summary>
            Analyzer used at search time </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.m_indexAnalyzer">
            <summary>
            Analyzer used at index time </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.writer">
            <summary>
            Used for ongoing NRT additions/updates. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.m_searcherMgr">
            <summary>
            <see cref="T:Lucene.Net.Search.IndexSearcher"/> used for lookups. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS">
            <summary>
            Default minimum number of leading characters before
             PrefixQuery is used (4). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.SORT">
            <summary>
            How we sort the postings and search results. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Create a new instance, loading from a previously built
            <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester"/> directory, if it exists. 
            This directory must be
            private to the infix suggester (i.e., not an external
            Lucene index).  Note that <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Dispose"/>
            will also dispose the provided directory. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32)">
            <summary>
            Create a new instance, loading from a previously built
            <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester"/> directory, if it exists.  This directory must be
            private to the infix suggester (i.e., not an external
            Lucene index).  Note that <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Dispose"/>
            will also dispose the provided directory.
            </summary>
             <param name="minPrefixChars"> Minimum number of leading characters
                before <see cref="T:Lucene.Net.Search.PrefixQuery"/> is used (default 4).
                Prefixes shorter than this are indexed as character
                ngrams (increasing index size but making lookups
                faster). </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32,System.Boolean)">
            <summary>
            Create a new instance, loading from a previously built
            <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester"/> directory, if it exists.  This directory must be
            private to the infix suggester (i.e., not an external
            Lucene index).  Note that <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Dispose"/>
            will also dispose the provided directory.
            </summary>
             <param name="minPrefixChars"> Minimum number of leading characters
                before <see cref="T:Lucene.Net.Search.PrefixQuery"/> is used (default 4).
                Prefixes shorter than this are indexed as character
                ngrams (increasing index size but making lookups
                faster). </param>
             <param name="commitOnBuild"> Call commit after the index has finished building. This
             would persist the suggester index to disk and future instances of this suggester can
             use this pre-built dictionary. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.GetIndexWriterConfig(Lucene.Net.Util.LuceneVersion,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.OpenMode)">
            <summary>
            Override this to customize index settings, e.g. which
            codec to use. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.GetDirectory(System.IO.DirectoryInfo)">
            <summary>
            Subclass can override to choose a specific 
            <see cref="T:Lucene.Net.Store.Directory"/> implementation. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Add(Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int64,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new suggestion.  Be sure to use <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Update(Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int64,Lucene.Net.Util.BytesRef)"/>
            instead if you want to replace a previous suggestion.
            After adding or updating a batch of new suggestions,
            you must call <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Refresh"/> in the end in order to
            see the suggestions in <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int32,System.Boolean,System.Boolean)"/> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Update(Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int64,Lucene.Net.Util.BytesRef)">
            <summary>
            Updates a previous suggestion, matching the exact same
            text as before.  Use this to change the weight or
            payload of an already added suggstion.  If you know
            this text is not already present you can use <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Add(Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int64,Lucene.Net.Util.BytesRef)"/> 
            instead.  After adding or updating a batch of
            new suggestions, you must call <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Refresh"/> in the
            end in order to see the suggestions in <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int32,System.Boolean,System.Boolean)"/> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Refresh">
            <summary>
            Reopens the underlying searcher; it's best to "batch
            up" many additions/updates, and then call refresh
            once in the end. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.GetTextFieldType">
            <summary>
            Subclass can override this method to change the field type of the text field
            e.g. to change the index options
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.DoLookup(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Lookup, without any context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.GetLastTokenQuery(System.String)">
            <summary>
            This is called if the last token isn't ended
            (e.g. user did not type a space after it).  Return an
            appropriate <see cref="T:Lucene.Net.Search.Query"/> clause to add to the <see cref="T:Lucene.Net.Search.BooleanQuery"/>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Retrieve suggestions, specifying whether all terms
             must match (<paramref name="allTermsRequired"/>) and whether the hits
             should be highlighted (<paramref name="doHighlight"/>). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.CreateResults(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopFieldDocs,System.Int32,System.String,System.Boolean,System.Collections.Generic.ICollection{System.String},System.String)">
            <summary>
            Create the results based on the search hits.
            Can be overridden by subclass to add particular behavior (e.g. weight transformation) </summary>
            <exception cref="T:System.IO.IOException"> If there are problems reading fields from the underlying Lucene index. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.FinishQuery(Lucene.Net.Search.BooleanQuery,System.Boolean)">
            <summary>
            Subclass can override this to tweak the Query before
            searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Highlight(System.String,System.Collections.Generic.ICollection{System.String},System.String)">
            <summary>
            Override this method to customize the Object
            representing a single highlighted suggestions; the
            result is set on each <see cref="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.HighlightKey"/>
            member. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.AddNonMatch(System.Text.StringBuilder,System.String)">
            <summary>
            Called while highlighting a single result, to append a
            non-matching chunk of text from the suggestion to the
            provided fragments list. </summary>
            <param name="sb"> The <see cref="T:System.Text.StringBuilder"/> to append to </param>
            <param name="text"> The text chunk to add </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.AddWholeMatch(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Called while highlighting a single result, to append
            the whole matched token to the provided fragments list. </summary>
            <param name="sb"> The <see cref="T:System.Text.StringBuilder"/> to append to </param>
            <param name="surface"> The surface form (original) text </param>
            <param name="analyzed"> The analyzed token corresponding to the surface form text </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.AddPrefixMatch(System.Text.StringBuilder,System.String,System.String,System.String)">
            <summary>
            Called while highlighting a single result, to append a
            matched prefix token, to the provided fragments list. </summary>
            <param name="sb"> The <see cref="T:System.Text.StringBuilder"/> to append to </param>
            <param name="surface"> The fragment of the surface form
                   (indexed during <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester.Build(Lucene.Net.Search.Suggest.IInputEnumerator)"/>, corresponding to
                   this match </param>
            <param name="analyzed"> The analyzed token that matched </param>
            <param name="prefixToken"> The prefix of the token that matched </param>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester">
            <summary>
            Suggester that first analyzes the surface form, adds the
            analyzed form to a weighted FST, and then does the same
            thing at lookup time.  This means lookup is based on the
            analyzed form while suggestions are still the surface
            form(s).
            
            <para>
            This can result in powerful suggester functionality.  For
            example, if you use an analyzer removing stop words, 
            then the partial text "ghost chr..." could see the
            suggestion "The Ghost of Christmas Past". Note that
            position increments MUST NOT be preserved for this example
            to work, so you should call the constructor with 
            <see cref="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.preservePositionIncrements"/> parameter set to 
            false
            
            </para>
            <para>
            If SynonymFilter is used to map wifi and wireless network to
            hotspot then the partial text "wirele..." could suggest
            "wifi router".  Token normalization like stemmers, accent
            removal, etc., would allow suggestions to ignore such
            variations.
            
            </para>
            <para>
            When two matching suggestions have the same weight, they
            are tie-broken by the analyzed form.  If their analyzed
            form is the same then the order is undefined.
            
            </para>
            <para>
            There are some limitations:
            <list type="number">
            
              <item><description> A lookup from a query like "net" in English won't
                   be any different than "net " (ie, user added a
                   trailing space) because analyzers don't reflect
                   when they've seen a token separator and when they
                   haven't.</description></item>
            
              <item><description> If you're using <see cref="T:Lucene.Net.Analysis.Core.StopFilter"/>, and the user will
                   type "fast apple", but so far all they've typed is
                   "fast a", again because the analyzer doesn't convey whether
                   it's seen a token separator after the "a",
                   <see cref="T:Lucene.Net.Analysis.Core.StopFilter"/> will remove that "a" causing
                   far more matches than you'd expect.</description></item>
            
              <item><description> Lookups with the empty string return no results
                   instead of all results.</description></item>
            </list>
            
            @lucene.experimental
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.fst">
            <summary>
            FST(Weight,Surface):
            input is the analyzed form, with a null byte between terms
            weights are encoded as costs: (<see cref="F:System.Int32.MaxValue"/> - weight)
            surface is the original, unanalyzed form.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.indexAnalyzer">
            <summary>
            Analyzer that will be used for analyzing suggestions at
            index time.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.queryAnalyzer">
            <summary>
            Analyzer that will be used for analyzing suggestions at
            query time.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.exactFirst">
            <summary>
            True if exact match suggestions should always be returned first.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.preserveSep">
            <summary>
            True if separator between tokens should be preserved.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.SEP_LABEL">
            <summary>
            Represents the separation between tokens, if
            <see cref="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.PRESERVE_SEP"/> was specified 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.END_BYTE">
            <summary>
            Marks end of the analyzed input and start of dedup
             byte. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.maxSurfaceFormsPerAnalyzedForm">
            <summary>
            Maximum number of dup surface forms (different surface
             forms for the same analyzed form). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.maxGraphExpansions">
            <summary>
            Maximum graph paths to index for a single analyzed
             surface form.  This only matters if your analyzer
             makes lots of alternate paths (e.g. contains
             SynonymFilter). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.maxAnalyzedPathsForOneInput">
            <summary>
            Highest number of analyzed paths we saw for any single
             input surface form.  For analyzers that never create
             graphs this will always be 1. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.preservePositionIncrements">
            <summary>
            Whether position holes should appear in the automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.count">
            <summary>
            Number of entries the lookup was built with </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions,System.Int32,System.Int32,System.Boolean)">
            AnalyzingSuggester(analyzer, analyzer, SuggesterOptions.EXACT_FIRST | SuggesterOptions.PRESERVE_SEP, 256, -1, true)
            </see>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions,System.Int32,System.Int32,System.Boolean)">
            AnalyzingSuggester(indexAnalyzer, queryAnalyzer, SuggesterOptions.EXACT_FIRST | SuggesterOptions.PRESERVE_SEP, 256, -1, true)
            </see>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new suggester.
            </summary>
            <param name="indexAnalyzer"> Analyzer that will be used for
              analyzing suggestions while building the index. </param>
            <param name="queryAnalyzer"> Analyzer that will be used for
              analyzing query text during lookup </param>
            <param name="options"> see <see cref="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.EXACT_FIRST"/>, <see cref="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.PRESERVE_SEP"/> </param>
            <param name="maxSurfaceFormsPerAnalyzedForm"> Maximum number of
              surface forms to keep for a single analyzed form.
              When there are too many surface forms we discard the
              lowest weighted ones. </param>
            <param name="maxGraphExpansions"> Maximum number of graph paths
              to expand from the analyzed form.  Set this to -1 for
              no limit. </param>
            <param name="preservePositionIncrements"> Whether position holes
              should appear in the automata </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.GetSizeInBytes">
            <summary>
            Returns byte size of the underlying FST. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.ConvertAutomaton(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Used by subclass to change the lookup automaton, if
             necessary. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.GetFullPrefixPaths(System.Collections.Generic.IList{Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path{Lucene.Net.Util.Fst.PairOutputs{J2N.Numerics.Int64,Lucene.Net.Util.BytesRef}.Pair}},Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Fst.FST{Lucene.Net.Util.Fst.PairOutputs{J2N.Numerics.Int64,Lucene.Net.Util.BytesRef}.Pair})">
            <summary>
            Returns all prefix paths to initialize the search.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.Get(System.String)">
            <summary>
            Returns the weight associated with an input string,
            or null if it does not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.DecodeWeight(System.Int64)">
            <summary>
            cost -> weight </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester.EncodeWeight(System.Int64)">
            <summary>
            weight -> cost </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester">
             <summary>
             Extension of the <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester"/> which transforms the weight
             after search to take into account the position of the searched term into
             the indexed text.
             Please note that it increases the number of elements searched and applies the
             ponderation after. It might be costly for long suggestions.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.LINEAR_COEF">
            <summary>
            Coefficient used for linear blending
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.DEFAULT_NUM_FACTOR">
            <summary>
            Default factor
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.numFactor">
            <summary>
            Factor to multiply the number of searched elements
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.blenderType">
            <summary>
            Type of blender used by the suggester
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType">
            <summary>
            The different types of blender.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType.CUSTOM">
            <summary>
            Application dependent; override <see cref="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.CalculateCoefficient(System.Int32)"/>
            to compute it.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType.POSITION_LINEAR">
            <summary>
            weight*(1 - 0.10*position)
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL">
            <summary>
            weight/(1+position)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Create a new instance, loading from a previously built
            directory, if it exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32,Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType,System.Int32)">
            <summary>
            Create a new instance, loading from a previously built
            directory, if it exists.
            </summary>
            <param name="blenderType"> Type of blending strategy, see BlenderType for more precisions </param>
            <param name="numFactor">   Factor to multiply the number of searched elements before ponderate </param>
            <exception cref="T:System.IO.IOException"> If there are problems opening the underlying Lucene index. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32,Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BlenderType,System.Int32,System.Boolean)">
            <summary>
            Create a new instance, loading from a previously built
            directory, if it exists.
            </summary>
            <param name="blenderType"> Type of blending strategy, see BlenderType for more precisions </param>
            <param name="numFactor">   Factor to multiply the number of searched elements before ponderate </param>
             <param name="commitOnBuild"> Call commit after the index has finished building. This
             would persist the suggester index to disk and future instances of this suggester can
             use this pre-built dictionary. </param>
            <exception cref="T:System.IO.IOException"> If there are problems opening the underlying Lucene index. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.BoundedTreeAdd(J2N.Collections.Generic.SortedSet{Lucene.Net.Search.Suggest.Lookup.LookupResult},Lucene.Net.Search.Suggest.Lookup.LookupResult,System.Int32)">
            <summary>
            Add an element to the tree respecting a size limit
            </summary>
            <param name="results"> the tree to add in </param>
            <param name="result"> the result we try to add </param>
            <param name="num"> size limit </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.CreateCoefficient(Lucene.Net.Search.IndexSearcher,System.Int32,System.Collections.Generic.ICollection{System.String},System.String)">
            <summary>
            Create the coefficient to transform the weight.
            </summary>
            <param name="doc"> id of the document </param>
            <param name="matchedTokens"> tokens found in the query </param>
            <param name="prefixToken"> unfinished token in the query </param>
            <returns> the coefficient </returns>
            <exception cref="T:System.IO.IOException"> If there are problems reading term vectors from the underlying Lucene index. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.BlendedInfixSuggester.CalculateCoefficient(System.Int32)">
            <summary>
            Calculate the weight coefficient based on the position of the first matching word.
            Subclass should override it to adapt it to particular needs </summary>
            <param name="position"> of the first matching word in text </param>
            <returns> the coefficient </returns>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester">
            <summary>
            Builds an ngram model from the text sent to <see cref="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.Build(Lucene.Net.Search.Suggest.IInputEnumerator,System.Double)"/>
            and predicts based on the last grams-1 tokens in
            the request sent to <see cref="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Boolean,System.Int32)"/>.  This tries to
            handle the "long tail" of suggestions for when the
            incoming query is a never before seen query string.
            
            <para>Likely this suggester would only be used as a
            fallback, when the primary suggester fails to find
            any suggestions.
            
            </para>
            <para>Note that the weight for each suggestion is unused,
            and the suggestions are the analyzed forms (so your
            analysis process should normally be very "light").
            
            </para>
            <para>This uses the stupid backoff language model to smooth
            scores across ngram models; see 
            <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.76.1126">
            "Large language models in machine translation"</a> for details.
            
            </para>
            <para> From <see cref="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Boolean,System.Int32)"/>, the key of each result is the
            ngram token; the value is <see cref="F:System.Int64.MaxValue"/> * score (fixed
            point, cast to long).  Divide by <see cref="F:System.Int64.MaxValue"/> to get
            the score back, which ranges from 0.0 to 1.0.
            
            <c>onlyMorePopular</c> is unused.
            
            @lucene.experimental
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.CODEC_NAME">
            <summary>
            Codec name used in the header for the saved model. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.VERSION_START">
            <summary>
            Initial version of the the saved model file format. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.VERSION_CURRENT">
            <summary>
            Current version of the the saved model file format. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DEFAULT_GRAMS">
            <summary>
            By default we use a bigram model. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.ALPHA">
            <summary>
            The constant used for backoff smoothing; during
             lookup, this means that if a given trigram did not
             occur, and we backoff to the bigram, the overall score
             will be 0.4 times what the bigram model would have
             assigned. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.fst">
            <summary>
            Holds 1gram, 2gram, 3gram models as a single FST. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.indexAnalyzer">
            <summary>
            Analyzer that will be used for analyzing suggestions at
            index time.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.queryAnalyzer">
            <summary>
            Analyzer that will be used for analyzing suggestions at
            query time.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.count">
            <summary>
            Number of entries the lookup was built with </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DEFAULT_SEPARATOR">
            <summary>
            The default character used to join multiple tokens
            into a single ngram token.  The input tokens produced
            by the analyzer must not contain this character. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Instantiate, using the provided analyzer for both
            indexing and lookup, using bigram model by default. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Instantiate, using the provided indexing and lookup
            analyzers, using bigram model by default. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32)">
            <summary>
            Instantiate, using the provided indexing and lookup
            analyzers, with the specified model (2
            = bigram, 3 = trigram, etc.). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,System.Int32,System.Byte)">
            <summary>
            Instantiate, using the provided indexing and lookup
            analyzers, and specified model (2 = bigram, 3 =
            trigram ,etc.).  The <paramref name="separator"/> is passed to <see cref="M:Lucene.Net.Analysis.Shingle.ShingleFilter.SetTokenSeparator(System.String)"/>
            to join multiple
            tokens into a single ngram token; it must be an ascii
            (7-bit-clean) byte.  No input tokens should have this
            byte, otherwise <see cref="T:System.ArgumentException"/> is
            thrown. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.GetSizeInBytes">
            <summary>
            Returns byte size of the underlying FST. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.Build(Lucene.Net.Search.Suggest.IInputEnumerator,System.Double)">
            <summary>
            Build the suggest index, using up to the specified
            amount of temporary RAM while building.  Note that
            the weights for the suggestions are ignored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DoLookup(System.String,System.Int32)">
            <summary>
            Lookup, without any context. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Int32)">
            <summary>
            Retrieve suggestions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.EncodeWeight(System.Int64)">
            <summary>
            weight -> cost </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.DecodeWeight(System.Nullable{System.Int64})">
            <summary>
            cost -> weight </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FreeTextSuggester.Get(System.String)">
            <summary>
            Returns the weight associated with an input string,
            or null if it does not exist.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.FSTUtil">
            <summary>
            Exposes a utility method to enumerate all paths
            intersecting an <see cref="T:Lucene.Net.Util.Automaton.Automaton"/> with an <see cref="T:Lucene.Net.Util.Fst.FST"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1">
            <summary>
            Holds a pair (automaton, fst) of states and accumulated output in the intersected machine. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1.State">
            <summary>
            Node in the automaton where path ends: </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1.FstNode">
            <summary>
            Node in the <see cref="T:Lucene.Net.Util.Fst.FST"/> where path ends: </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1.Output">
            <summary>
            Output of the path so far: </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1.Input">
            <summary>
            Input of the path so far: </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.Path`1.#ctor(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.Fst.FST.Arc{`0},`0,Lucene.Net.Util.Int32sRef)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FSTUtil.IntersectPrefixPaths``1(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Fst.FST{``0})">
            <summary>
            Enumerates all minimal prefix paths in the automaton that also intersect the <see cref="T:Lucene.Net.Util.Fst.FST"/>,
            accumulating the <see cref="T:Lucene.Net.Util.Fst.FST"/> end node and output for each path.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester">
            <summary>
            Implements a fuzzy <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester"/>. The similarity measurement is
            based on the Damerau-Levenshtein (optimal string alignment) algorithm, though
            you can explicitly choose classic Levenshtein by passing <c>false</c>
            for the <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.transpositions"/> parameter.
            <para>
            At most, this query will match terms up to <see cref="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE"/>
            edits. Higher distances are not supported.  Note that the
            fuzzy distance is measured in "byte space" on the bytes
            returned by the <see cref="T:Lucene.Net.Analysis.TokenStream"/>'s <see cref="T:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute"/>, 
            usually UTF8.  By default
            the analyzed bytes must be at least 3 <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_MIN_FUZZY_LENGTH"/>
            bytes before any edits are
            considered.  Furthermore, the first 1 <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_NON_FUZZY_PREFIX"/>
            byte is not allowed to be
            edited.  We allow up to 1 <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_MAX_EDITS"/>
            edit.
            If <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.unicodeAware"/> parameter in the constructor is set to true, maxEdits,
            minFuzzyLength, transpositions and nonFuzzyPrefix are measured in Unicode code 
            points (actual letters) instead of bytes. 
            
            </para>
            <para>
            NOTE: This suggester does not boost suggestions that
            required no edits over suggestions that did require
            edits.  This is a known limitation.
            
            </para>
            <para>
            Note: complex query analyzers can have a significant impact on the lookup
            performance. It's recommended to not use analyzers that drop or inject terms
            like synonyms to keep the complexity of the prefix intersection low for good
            lookup performance. At index time, complex analyzers can safely be used.
            </para>
            
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_UNICODE_AWARE">
            <summary>
            Measure <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.maxEdits"/>, <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.minFuzzyLength"/>, 
            <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.transpositions"/>, and <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.nonFuzzyPrefix"/> 
            parameters in Unicode code points (actual letters)
            instead of bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_MIN_FUZZY_LENGTH">
            <summary>
            The default minimum length of the key passed to <see cref="T:Lucene.Net.Search.Suggest.Lookup"/>
            before any edits are allowed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_NON_FUZZY_PREFIX">
            <summary>
            The default prefix length where edits are not allowed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_MAX_EDITS">
            <summary>
            The default maximum number of edits for fuzzy
            suggestions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_TRANSPOSITIONS">
            <summary>
            The default transposition value passed to <see cref="T:Lucene.Net.Util.Automaton.LevenshteinAutomata"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester"/> instance initialized with default values.
            </summary>
            <param name="analyzer"> The <see cref="T:Lucene.Net.Analysis.Analyzer"/> used for this suggester. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester"/> instance with an index &amp; a query analyzer initialized with default values.
            </summary>
            <param name="indexAnalyzer">
                      <see cref="T:Lucene.Net.Analysis.Analyzer"/> that will be used for analyzing suggestions while building the index. </param>
            <param name="queryAnalyzer">
                      <see cref="T:Lucene.Net.Analysis.Analyzer"/> that will be used for analyzing query text during lookup </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.#ctor(Lucene.Net.Analysis.Analyzer,Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a <see cref="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester"/> instance.
            </summary>
            <param name="indexAnalyzer"> The <see cref="T:Lucene.Net.Analysis.Analyzer"/> that will be used for
                   analyzing suggestions while building the index. </param>
            <param name="queryAnalyzer"> The <see cref="T:Lucene.Net.Analysis.Analyzer"/> that will be used for
                   analyzing query text during lookup </param>
            <param name="options"> see <see cref="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.EXACT_FIRST"/>, <see cref="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.PRESERVE_SEP"/> </param>
            <param name="maxSurfaceFormsPerAnalyzedForm"> Maximum number of
                   surface forms to keep for a single analyzed form.
                   When there are too many surface forms we discard the
                   lowest weighted ones. </param>
            <param name="maxGraphExpansions"> Maximum number of graph paths
                   to expand from the analyzed form.  Set this to -1 for
                   no limit. </param>
            <param name="preservePositionIncrements"> Whether position holes should appear in the automaton </param>
            <param name="maxEdits"> must be &gt;= 0 and &lt;= <see cref="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE"/>. </param>
            <param name="transpositions"> <c>true</c> if transpositions should be treated as a primitive 
                   edit operation. If this is false, comparisons will implement the classic
                   Levenshtein algorithm. </param>
            <param name="nonFuzzyPrefix"> length of common (non-fuzzy) prefix (see default <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_NON_FUZZY_PREFIX"/> </param>
            <param name="minFuzzyLength"> minimum length of lookup key before any edits are allowed (see default <see cref="F:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester.DEFAULT_MIN_FUZZY_LENGTH"/>) </param>
            <param name="unicodeAware"> operate Unicode code points instead of bytes. </param>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions">
            <summary>
            LUCENENET specific type for specifying <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester"/> 
            and <see cref="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester"/> options. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.EXACT_FIRST">
            <summary>
            Always return the exact match first, regardless of score.  
            This has no performance impact but could result in
            low-quality suggestions. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Analyzing.SuggesterOptions.PRESERVE_SEP">
            <summary>
            Preserve token separators when matching. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Analyzing.SuggestStopFilter">
            <summary>
            Like <see cref="T:Lucene.Net.Analysis.Core.StopFilter"/> except it will not remove the
            last token if that token was not followed by some token
            separator.  For example, a query 'find the' would
            preserve the 'the' since it was not followed by a space or
            punctuation or something, and mark it KEYWORD so future
            stemmers won't touch it either while a query like "find
            the popsicle' would remove 'the' as a stopword.
            
            <para>
            Normally you'd use the ordinary <see cref="T:Lucene.Net.Analysis.Core.StopFilter"/>
            in your indexAnalyzer and then this class in your
            queryAnalyzer, when using one of the analyzing suggesters. 
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Analyzing.SuggestStopFilter.#ctor(Lucene.Net.Analysis.TokenStream,Lucene.Net.Analysis.Util.CharArraySet)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.BufferedInputEnumerator">
            <summary>
            This wrapper buffers incoming elements.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_entries">
            <summary>
            buffered term entries </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_payloads">
            <summary>
            buffered payload entries </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_contextSets">
            <summary>
            buffered context set entries </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_curPos">
            <summary>
            current buffer position </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_freqs">
            <summary>
            buffered weights, parallel with <see cref="F:Lucene.Net.Search.Suggest.BufferedInputEnumerator.m_entries"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.BufferedInputEnumerator.#ctor(Lucene.Net.Search.Suggest.IInputEnumerator)">
            <summary>
            Creates a new iterator, buffering entries from the specified iterator </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper">
            <summary>
            This wrapper buffers incoming elements.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper.m_entries">
            <summary>
            buffered term entries </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper.m_curPos">
            <summary>
            current buffer position </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper.m_freqs">
            <summary>
            buffered weights, parallel with <see cref="F:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper.m_entries"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.BufferingTermFreqEnumeratorWrapper.#ctor(Lucene.Net.Search.Spell.ITermFreqEnumerator)">
            <summary>
            Creates a new iterator, buffering entries from the specified iterator
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.DocumentDictionary">
            <summary>
            <para>
            Dictionary with terms, weights, payload (optional) and contexts (optional)
            information taken from stored/indexed fields in a Lucene index.
            </para>
            <b>NOTE:</b> 
             <list type="bullet">
               <item><description>
                 The term and (optionally) payload fields have to be
                 stored
               </description></item>
               <item><description>
                 The weight field can be stored or can be a <see cref="T:Lucene.Net.Index.NumericDocValues"/>.
                 If the weight field is not defined, the value of the weight is <c>0</c>
               </description></item>
               <item><description>
                 if any of the term or (optionally) payload fields supplied
                 do not have a value for a document, then the document is 
                 skipped by the dictionary
               </description></item>
             </list>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentDictionary.m_reader">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReader"/> to load documents from </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentDictionary.m_payloadField">
            <summary>
            Field to read payload from </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentDictionary.m_contextsField">
            <summary>
            Field to read contexts from </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,System.String)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms and <paramref name="weightField"/> for the weights that will be used for
            the corresponding terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,System.String,System.String)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms, <paramref name="weightField"/> for the weights that will be used for the 
            the corresponding terms and <paramref name="payloadField"/> for the corresponding payloads
            for the entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms, <paramref name="weightField"/> for the weights that will be used for the 
            the corresponding terms, <paramref name="payloadField"/> for the corresponding payloads
            for the entry and <paramref name="contextsField"/> for associated contexts.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.DocumentDictionary.DocumentInputEnumerator">
            <summary>
            Implements <see cref="T:Lucene.Net.Search.Suggest.IInputEnumerator"/> from stored fields. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentDictionary.DocumentInputEnumerator.#ctor(Lucene.Net.Search.Suggest.DocumentDictionary,System.Boolean,System.Boolean)">
            <summary>
            Creates an iterator over term, weight and payload fields from the lucene
            index. Setting <paramref name="hasPayloads"/> to <c>false</c>, implies an enumerator
            over only term and weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentDictionary.DocumentInputEnumerator.GetWeight(Lucene.Net.Documents.Document,System.Int32)">
            <summary>
            Returns the value of the <see cref="P:Lucene.Net.Search.Suggest.DocumentDictionary.DocumentInputEnumerator.Weight"/> property for the current document.
            Retrieves the value for the <see cref="P:Lucene.Net.Search.Suggest.DocumentDictionary.DocumentInputEnumerator.Weight"/> property if its stored (using <paramref name="doc"/>)
            or if its indexed as <see cref="T:Lucene.Net.Index.NumericDocValues"/> (using <paramref name="docId"/>) for the document.
            If no value is found, then the weight is 0.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary">
            <summary>
            <para>
            Dictionary with terms and optionally payload information 
            taken from stored fields in a Lucene index. Similar to 
            <see cref="T:Lucene.Net.Search.Suggest.DocumentDictionary"/>, except it obtains the weight
            of the terms in a document based on a <see cref="T:Lucene.Net.Queries.Function.ValueSource"/>.
            </para>
            <b>NOTE:</b> 
             <list type="bullet">
               <item><description>
                 The term and (optionally) payload fields have to be
                 stored
               </description></item>
               <item><description>
                 if the term or (optionally) payload fields supplied
                 do not have a value for a document, then the document is 
                 rejected by the dictionary
               </description></item>
             </list>
             <para>
             In practice the <see cref="T:Lucene.Net.Queries.Function.ValueSource"/> will likely be obtained
             using the lucene expression module. The following example shows
             how to create a <see cref="T:Lucene.Net.Queries.Function.ValueSource"/> from a simple addition of two
             fields:
             <code>
               Expression expression = JavascriptCompiler.Compile("f1 + f2");
               SimpleBindings bindings = new SimpleBindings();
               bindings.Add(new SortField("f1", SortField.Type_e.LONG));
               bindings.Add(new SortField("f2", SortField.Type_e.LONG));
               ValueSource valueSource = expression.GetValueSource(bindings);
             </code>
             </para>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Queries.Function.ValueSource,System.String,System.String)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms, <paramref name="payload"/> for the corresponding payloads, <paramref name="contexts"/>
            for the associated contexts and uses the <paramref name="weightsValueSource"/> supplied 
            to determine the score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Queries.Function.ValueSource,System.String)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms, <paramref name="payload"/> for the corresponding payloads
            and uses the <paramref name="weightsValueSource"/> supplied to determine the 
            score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.#ctor(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Queries.Function.ValueSource)">
            <summary>
            Creates a new dictionary with the contents of the fields named <paramref name="field"/>
            for the terms and uses the <paramref name="weightsValueSource"/> supplied to determine the 
            score.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.DocumentValueSourceInputEnumerator.leaves">
            <summary>
            leaves of the reader </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.DocumentValueSourceInputEnumerator.starts">
            <summary>
            starting docIds of all the leaves </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.DocumentValueSourceInputEnumerator.currentLeafIndex">
            <summary>
            current leave index </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.DocumentValueSourceInputEnumerator.GetWeight(Lucene.Net.Documents.Document,System.Int32)">
            <summary>
            Returns the weight for the current <paramref name="docId"/> as computed 
            by the <see cref="F:Lucene.Net.Search.Suggest.DocumentValueSourceDictionary.weightsValueSource"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.FileDictionary">
            <summary>
            Dictionary represented by a text file.
            
            <para>Format allowed: 1 entry per line:</para>
            <para>An entry can be: </para>
            <list type="number">
            <item><description>suggestion</description></item>
            <item><description>suggestion <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.fieldDelimiter"/> weight</description></item>
            <item><description>suggestion <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.fieldDelimiter"/> weight <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.fieldDelimiter"/> payload</description></item>
            </list>
            where the default <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.fieldDelimiter"/> is <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.DEFAULT_FIELD_DELIMITER"/> (a tab)
            <para>
            <b>NOTE:</b> 
            <list type="number">
            <item><description>In order to have payload enabled, the first entry has to have a payload</description></item>
            <item><description>If the weight for an entry is not specified then a value of 1 is used</description></item>
            <item><description>A payload cannot be specified without having the weight specified for an entry</description></item>
            <item><description>If the payload for an entry is not specified (assuming payload is enabled) 
             then an empty payload is returned</description></item>
            <item><description>An entry cannot have more than two <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.fieldDelimiter"/>s</description></item>
            </list>
            </para>
            <c>Example:</c><para/>
            word1 word2 TAB 100 TAB payload1<para/>
            word3 TAB 101<para/>
            word4 word3 TAB 102<para/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.FileDictionary.DEFAULT_FIELD_DELIMITER">
            <summary>
            Tab-delimited fields are most common thus the default, but one can override this via the constructor
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.FileDictionary.#ctor(System.IO.Stream)">
            <summary>
            Creates a dictionary based on an inputstream.
            Using <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.DEFAULT_FIELD_DELIMITER"/> as the 
            field seperator in a line.
            <para>
            NOTE: content is treated as UTF-8
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.FileDictionary.#ctor(System.IO.TextReader)">
            <summary>
            Creates a dictionary based on a reader.
            Using <see cref="F:Lucene.Net.Search.Suggest.FileDictionary.DEFAULT_FIELD_DELIMITER"/> as the 
            field seperator in a line.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.FileDictionary.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Creates a dictionary based on a reader. 
            Using <paramref name="fieldDelimiter"/> to seperate out the
            fields in a line.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.FileDictionary.#ctor(System.IO.Stream,System.String)">
            <summary>
            Creates a dictionary based on an inputstream.
            Using <paramref name="fieldDelimiter"/> to seperate out the
            fields in a line.
            <para>
            NOTE: content is treated as UTF-8
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter">
            <summary>
            Collects <see cref="T:Lucene.Net.Util.BytesRef"/> and then allows one to iterate over their sorted order. Implementations
            of this interface will be called in a single-threaded scenario.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter.Add(Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a single suggestion entry (possibly compound with its bucket).
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O exception occurs. </exception>
            <exception cref="T:System.InvalidOperationException"> If an addition attempt is performed after
            a call to <see cref="M:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter.GetEnumerator"/> has been made. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter.GetEnumerator">
            <summary>
            Sorts the entries added in <see cref="M:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter.Add(Lucene.Net.Util.BytesRef)"/> and returns 
            an enumerator over all sorted entries.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O exception occurs. </exception>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter.Comparer">
            <summary>
            Comparer used to determine the sort order of entries.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.ExternalRefSorter">
            <summary>
            Builds and iterates over sequences stored on disk.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.ExternalRefSorter.#ctor(Lucene.Net.Util.OfflineSorter)">
            <summary>
            Will buffer all sequences to a temporary file and then sort (all on-disk).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.ExternalRefSorter.Dispose">
            <summary>
            Removes any written temporary files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.ExternalRefSorter.ByteSequenceEnumerator">
            <summary>
            Iterate over byte refs in a file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion">
            <summary>
            Finite state automata based implementation of "autocomplete" functionality.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder"/>
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion">
            <summary>
            A single completion for a given key.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion.Utf8">
            <summary>
            UTF-8 bytes of the suggestion </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion.Bucket">
            <summary>
            source bucket (weight) of the suggestion </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion.CompareTo(Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion)">
            <seealso cref="M:Lucene.Net.Util.BytesRef.CompareTo(System.Object)"></seealso>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.DEFAULT_BUCKETS">
            <summary>
            Default number of buckets.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.EMPTY_RESULT">
            <summary>
            An empty result. Keep this an <see cref="T:System.Collections.Generic.List`1"/> to keep all the returned
            lists of single type (monomorphic calls).
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.automaton">
            <summary>
            Finite state automaton encoding all the lookup terms. See class notes for
            details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.rootArcs">
            <summary>
            An array of arcs leaving the root automaton state and encoding weights of
            all completions in their sub-trees.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.exactFirst">
            <seealso cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.#ctor(Lucene.Net.Util.Fst.FST{System.Object},System.Boolean,System.Boolean)" />
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.higherWeightsFirst">
            <seealso cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.#ctor(Lucene.Net.Util.Fst.FST{System.Object},System.Boolean,System.Boolean)" />
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.#ctor(Lucene.Net.Util.Fst.FST{System.Object},System.Boolean,System.Boolean)">
            <summary>
            Constructs an FSTCompletion, specifying higherWeightsFirst and exactFirst. </summary>
            <param name="automaton">
                     Automaton with completions. See <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder"/>. </param>
            <param name="higherWeightsFirst">
                     Return most popular suggestions first. This is the default
                     behavior for this implementation. Setting it to <c>false</c>
                     has no effect (use constant term weights to sort alphabetically
                     only). </param>
            <param name="exactFirst">
                     Find and push an exact match to the first position of the result
                     list if found. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.#ctor(Lucene.Net.Util.Fst.FST{System.Object})">
            <summary>
            Defaults to higher weights first and exact first. </summary>
            <seealso cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.#ctor(Lucene.Net.Util.Fst.FST{System.Object},System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.CacheRootArcs(Lucene.Net.Util.Fst.FST{System.Object})">
            <summary>
            Cache the root node's output arcs starting with completions with the
            highest weights.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.GetExactMatchStartingFromRootArc(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the first exact match by traversing root arcs, starting from the
            arc <paramref name="rootArcIndex"/>.
            </summary>
            <param name="rootArcIndex">
                     The first root arc index in <see cref="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.rootArcs"/> to consider when
                     matching.
            </param>
            <param name="utf8">
                     The sequence of utf8 bytes to follow.
            </param>
            <returns> Returns the bucket number of the match or <code>-1</code> if no
                    match was found. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.DoLookup(System.String,System.Int32)">
            <summary>
            Lookup suggestions to <paramref name="key"/>.
            </summary>
            <param name="key">
                     The prefix to which suggestions should be sought. </param>
            <param name="num">
                     At most this number of suggestions will be returned. </param>
            <returns> Returns the suggestions, sorted by their approximated weight first
                    (decreasing) and then alphabetically (UTF-8 codepoint order). </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.LookupSortedAlphabetically(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Lookup suggestions sorted alphabetically <c>if weights are not
            constant</c>. This is a workaround: in general, use constant weights for
            alphabetically sorted result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.LookupSortedByWeight(Lucene.Net.Util.BytesRef,System.Int32,System.Boolean)">
            <summary>
            Lookup suggestions sorted by weight (descending order).
            </summary>
            <param name="collectAll">
                     If <c>true</c>, the routine terminates immediately when
                     <paramref name="num"/> suggestions have been collected. If
                     <c>false</c>, it will collect suggestions from all weight
                     arcs (needed for <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.LookupSortedAlphabetically(Lucene.Net.Util.BytesRef,System.Int32)"/>. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.CheckExistingAndReorder(System.Collections.Generic.IList{Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion},Lucene.Net.Util.BytesRef)">
            <summary>
            Checks if the list of
            <see cref="T:Lucene.Net.Search.Suggest.Lookup.LookupResult"/>s already has a
            <paramref name="key"/>. If so, reorders that
            <see cref="T:Lucene.Net.Search.Suggest.Lookup.LookupResult"/> to the first
            position.
            </summary>
            <returns> 
            Returns <c>true</c> if and only if <paramref name="list"/> contained
            <paramref name="key"/>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.DescendWithPrefix(Lucene.Net.Util.Fst.FST.Arc{System.Object},Lucene.Net.Util.BytesRef)">
            <summary>
            Descend along the path starting at <paramref name="arc"/> and going through bytes
            in the argument.
            </summary>
            <param name="arc">
                     The starting arc. This argument is modified in-place. </param>
            <param name="utf8">
                     The term to descend along. </param>
            <returns> If <c>true</c>, <paramref name="arc"/> will be set to the arc
                    matching last byte of <c>term</c>. <c>false</c> is
                    returned if no such prefix exists. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.Collect(System.Collections.Generic.IList{Lucene.Net.Search.Suggest.Fst.FSTCompletion.Completion},System.Int32,System.Int32,Lucene.Net.Util.BytesRef,Lucene.Net.Util.Fst.FST.Arc{System.Object})">
            <summary>
            Recursive collect lookup results from the automaton subgraph starting at
            <paramref name="arc"/>.
            </summary>
            <param name="num">
                     Maximum number of results needed (early termination). </param>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Fst.FSTCompletion.BucketCount">
            <summary>
            Returns the bucket count (discretization thresholds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.GetBucket(System.String)">
            <summary>
            Returns the bucket assigned to a given key (if found) or <c>-1</c> if
            no exact match exists.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Fst.FSTCompletion.FST">
            <summary>
            Returns the internal automaton.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder">
            <summary>
            Finite state automata based implementation of "autocomplete" functionality.
            
            <h2>Implementation details</h2>
            
            <para>
            The construction step in the object finalizer works as follows:
            <list type="bullet">
            <item><description>A set of input terms and their buckets is given.</description></item>
            <item><description>All terms in the input are prefixed with a synthetic pseudo-character
            (code) of the weight bucket the term fell into. For example a term
            <c>abc</c> with a discretized weight equal '1' would become
            <c>1abc</c>.</description></item>
            <item><description>The terms are then sorted by their raw value of UTF-8 character values
            (including the synthetic bucket code in front).</description></item>
            <item><description>A finite state automaton (<see cref="T:Lucene.Net.Util.Fst.FST"/>) is constructed from the input. The
            root node has arcs labeled with all possible weights. We cache all these
            arcs, highest-weight first.</description></item>
            </list>
            
            </para>
            <para>
            At runtime, in <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletion.DoLookup(System.String,System.Int32)"/>, 
            the automaton is utilized as follows:
            <list type="bullet">
            <item><description>For each possible term weight encoded in the automaton (cached arcs from
            the root above), starting with the highest one, we descend along the path of
            the input key. If the key is not a prefix of a sequence in the automaton
            (path ends prematurely), we exit immediately -- no completions.</description></item>
            <item><description>Otherwise, we have found an internal automaton node that ends the key.
            <b>The entire subautomaton (all paths) starting from this node form the key's
            completions.</b> We start the traversal of this subautomaton. Every time we
            reach a final state (arc), we add a single suggestion to the list of results
            (the weight of this suggestion is constant and equal to the root path we
            started from). The tricky part is that because automaton edges are sorted and
            we scan depth-first, we can terminate the entire procedure as soon as we
            collect enough suggestions the user requested.</description></item>
            <item><description>In case the number of suggestions collected in the step above is still
            insufficient, we proceed to the next (smaller) weight leaving the root node
            and repeat the same algorithm again.</description></item>
            </list>
            
            <h2>Runtime behavior and performance characteristic</h2>
            
            The algorithm described above is optimized for finding suggestions to short
            prefixes in a top-weights-first order. This is probably the most common use
            case: it allows presenting suggestions early and sorts them by the global
            frequency (and then alphabetically).
            
            </para>
            <para>
            If there is an exact match in the automaton, it is returned first on the
            results list (even with by-weight sorting).
            
            </para>
            <para>
            Note that the maximum lookup time for <b>any prefix</b> is the time of
            descending to the subtree, plus traversal of the subtree up to the number of
            requested suggestions (because they are already presorted by weight on the
            root level and alphabetically at any node level).
            
            </para>
            <para>
            To order alphabetically only (no ordering by priorities), use identical term
            weights for all terms. Alphabetical suggestions are returned even if
            non-constant weights are used, but the algorithm for doing this is
            suboptimal.
            
            </para>
            <para>
            "alphabetically" in any of the documentation above indicates UTF-8
            representation order, nothing else.
            
            </para>
            <para>
            <b>NOTE</b>: the FST file format is experimental and subject to suddenly
            change, requiring you to rebuild the FST suggest index.
            
            </para>
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/>
            @lucene.experimental
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.DEFAULT_BUCKETS">
            <summary>
            Default number of buckets.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.buckets">
            <summary>
            The number of separate buckets for weights (discretization). The more
            buckets, the more fine-grained term weights (priorities) can be assigned.
            The speed of lookup will not decrease for prefixes which have
            highly-weighted completions (because these are filled-in first), but will
            decrease significantly for low-weighted terms (but these should be
            infrequent, so it is all right).
            
            <para>
            The number of buckets must be within [1, 255] range.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.automaton">
            <summary>
            Finite state automaton encoding all the lookup terms. See class notes for
            details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.sorter">
            <summary>
            FST construction require re-sorting the input. This is the class that
            collects all the input entries, their weights and then provides sorted
            order.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.scratch">
            <summary>
            Scratch buffer for <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.Add(Lucene.Net.Util.BytesRef,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.shareMaxTailLength">
            <summary>
            Max tail sharing length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.#ctor">
            <summary>
            Creates an <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/> with default options: 10 buckets, exact match
            promoted to first position and <see cref="T:Lucene.Net.Search.Suggest.InMemorySorter"/> with a comparer obtained from
            <see cref="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUnicodeComparer"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.#ctor(System.Int32,Lucene.Net.Search.Suggest.Fst.IBytesRefSorter,System.Int32)">
            <summary>
            Creates an FSTCompletion with the specified options. </summary>
            <param name="buckets">
                     The number of buckets for weight discretization. Buckets are used
                     in <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.Add(Lucene.Net.Util.BytesRef,System.Int32)"/> and must be smaller than the number
                     given here.
            </param>
            <param name="sorter">
                     <see cref="T:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter"/> used for re-sorting input for the automaton.
                     For large inputs, use on-disk sorting implementations. The sorter
                     is closed automatically in <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.Build"/> if it implements
                     <see cref="T:System.IDisposable"/>.
            </param>
            <param name="shareMaxTailLength">
                     Max shared suffix sharing length.
                     
                     See the description of this parameter in <see cref="T:Lucene.Net.Util.Fst.Builder"/>'s constructor.
                     In general, for very large inputs you'll want to construct a non-minimal
                     automaton which will be larger, but the construction will take far less ram.
                     For minimal automata, set it to <see cref="F:System.Int32.MaxValue"/>. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.Add(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Appends a single suggestion and its weight to the internal buffers.
            </summary>
            <param name="utf8">
                     The suggestion (utf8 representation) to be added. The content is
                     copied and the object can be reused. </param>
            <param name="bucket">
                     The bucket to place this suggestion in. Must be non-negative and
                     smaller than the number of buckets passed in the constructor.
                     Higher numbers indicate suggestions that should be presented
                     before suggestions placed in smaller buckets. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.Build">
            <summary>
            Builds the final automaton from a list of added entries. This method may
            take a longer while as it needs to build the automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionBuilder.BuildAutomaton(Lucene.Net.Search.Suggest.Fst.IBytesRefSorter)">
            <summary>
            Builds the final automaton from a list of entries.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup">
            <summary>
            An adapter from <see cref="T:Lucene.Net.Search.Suggest.Lookup"/> API to <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/>.
            
            <para>This adapter differs from <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/> in that it attempts
            to discretize any "weights" as passed from in <see cref="P:Lucene.Net.Search.Suggest.IInputEnumerator.Weight"/>
            to match the number of buckets. For the rationale for bucketing, see
            <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/>.
            
            </para>
            <para><b>Note:</b>Discretization requires an additional sorting pass.
            
            </para>
            <para>The range of weights for bucketing/ discretization is determined 
            by sorting the input by weight and then dividing into
            equal ranges. Then, scores within each range are assigned to that bucket. 
            
            </para>
            <para>Note that this means that even large differences in weights may be lost 
            during automaton construction, but the overall distinction between "classes"
            of weights will be preserved regardless of the distribution of weights. 
            
            </para>
            <para>For fine-grained control over which weights are assigned to which buckets,
            use <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/> directly or <see cref="T:Lucene.Net.Search.Suggest.Tst.TSTLookup"/>, for example.
            
            </para>
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/>
            @lucene.experimental
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.INVALID_BUCKETS_COUNT">
            <summary>
            An invalid bucket count if we're creating an object
            of this class from an existing FST.
            </summary>
            <seealso cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.#ctor(Lucene.Net.Search.Suggest.Fst.FSTCompletion,System.Boolean)"/>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.sharedTailLength">
            <summary>
            Shared tail length for conflating in the created automaton. Setting this
            to larger values (<see cref="F:System.Int32.MaxValue"/>) will create smaller (or minimal) 
            automata at the cost of RAM for keeping nodes hash in the <see cref="T:Lucene.Net.Util.Fst.FST"/>. 
             
            <para>Empirical pick.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.higherWeightsCompletion">
            <summary>
            Automaton used for completions with higher weights reordering.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.normalCompletion">
            <summary>
            Automaton used for normal completions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.count">
            <summary>
            Number of entries the lookup was built with </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.#ctor">
            <summary>
            This constructor prepares for creating a suggested FST using the
            <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.Build(Lucene.Net.Search.Suggest.IInputEnumerator)"/> method. The number of weight
            discretization buckets is set to <see cref="F:Lucene.Net.Search.Suggest.Fst.FSTCompletion.DEFAULT_BUCKETS"/> and
            exact matches are promoted to the top of the suggestions list.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.#ctor(System.Int32,System.Boolean)">
            <summary>
            This constructor prepares for creating a suggested FST using the
            <see cref="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.Build(Lucene.Net.Search.Suggest.IInputEnumerator)"/> method.
            </summary>
            <param name="buckets">
                     The number of weight discretization buckets (see
                     <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/> for details).
            </param>
            <param name="exactMatchFirst">
                     If <c>true</c> exact matches are promoted to the top of the
                     suggestions list. Otherwise they appear in the order of
                     discretized weight and alphabetical within the bucket. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.#ctor(Lucene.Net.Search.Suggest.Fst.FSTCompletion,System.Boolean)">
            <summary>
            This constructor takes a pre-built automaton.
            </summary>
             <param name="completion"> 
                     An instance of <see cref="T:Lucene.Net.Search.Suggest.Fst.FSTCompletion"/>. </param>
             <param name="exactMatchFirst">
                     If <code>true</code> exact matches are promoted to the top of the
                     suggestions list. Otherwise they appear in the order of
                     discretized weight and alphabetical within the bucket. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.EncodeWeight(System.Int64)">
            <summary>
            weight -> cost </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.FSTCompletionLookup.Get(System.String)">
            <summary>
            Returns the bucket (weight) as a <see cref="T:long?"/> for the provided key if it exists,
            otherwise null if it does not.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup">
            <summary>
            Suggester based on a weighted FST: it first traverses the prefix, 
            then walks the <i>n</i> shortest paths to retrieve top-ranked
            suggestions.
            <para>
            <b>NOTE</b>:
            Input weights must be between 0 and <see cref="F:System.Int32.MaxValue"/>, any
            other values will be rejected.
            
            @lucene.experimental
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.fst">
            <summary>
            FST{long?}, weights are encoded as costs: (int.MaxValue-weight)
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.exactFirst">
            <summary>
            True if exact match suggestions should always be returned first.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.count">
            <summary>
            Number of entries the lookup was built with </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.#ctor">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.#ctor(System.Boolean)">WFSTCompletionLookup(true)</see>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.#ctor(System.Boolean)">
            <summary>
            Creates a new suggester.
            </summary>
            <param name="exactFirst"> <code>true</code> if suggestions that match the 
                   prefix exactly should always be returned first, regardless
                   of score. This has no performance impact, but could result
                   in low-quality suggestions. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.Get(System.String)">
            <summary>
            Returns the weight associated with an input string,
            or null if it does not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.DecodeWeight(System.Int64)">
            <summary>
            cost -> weight </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.EncodeWeight(System.Int64)">
            <summary>
            weight -> cost </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Fst.WFSTCompletionLookup.GetSizeInBytes">
            <summary>
            Returns byte size of the underlying FST. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.InMemorySorter">
            <summary>
            An <see cref="T:Lucene.Net.Search.Suggest.Fst.IBytesRefSorter"/> that keeps all the entries in memory.
            @lucene.experimental
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.InMemorySorter.#ctor(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Creates an InMemorySorter, sorting entries by the
            provided comparer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.IInputEnumerator">
            <summary>
            Interface for enumerating term,weight,payload triples for suggester consumption;
            currently only <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingSuggester"/>, <see cref="T:Lucene.Net.Search.Suggest.Analyzing.FuzzySuggester"/>
            and <see cref="T:Lucene.Net.Search.Suggest.Analyzing.AnalyzingInfixSuggester"/> support payloads.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.IInputEnumerator.Weight">
            <summary>
            A term's weight, higher numbers mean better suggestions. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.IInputEnumerator.Payload">
            <summary>
            An arbitrary byte[] to record per suggestion.  See
            <see cref="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.Payload"/> to retrieve the payload
            for each suggestion. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.IInputEnumerator.HasPayloads">
            <summary>
            Returns true if the iterator has payloads </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.IInputEnumerator.Contexts">
            <summary>
            A term's contexts context can be used to filter suggestions.
            May return null, if suggest entries do not have any context
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.IInputEnumerator.HasContexts">
            <summary>
            Returns true if the iterator has contexts </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.InputEnumerator.EMPTY">
            <summary>
            Singleton <see cref="T:Lucene.Net.Search.Suggest.IInputEnumerator"/> that iterates over 0 <see cref="T:Lucene.Net.Util.BytesRef"/>s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.InputEnumeratorWrapper">
            <summary>
            Wraps a <see cref="T:Lucene.Net.Util.IBytesRefEnumerator"/> as a suggester <see cref="T:Lucene.Net.Search.Suggest.IInputEnumerator"/>, with all weights
            set to <c>1</c> and carries no payload
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.InputEnumeratorWrapper.#ctor(Lucene.Net.Util.IBytesRefEnumerator)">
            <summary>
            Creates a new wrapper, wrapping the specified iterator and 
            specifying a weight value of <c>1</c> for all terms 
            and nullifies associated payloads.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup">
            <summary>
            Suggest implementation based on 
            <a href="http://jaspell.sourceforge.net/">JaSpell</a>.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie"/>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.count">
            <summary>
            Number of entries the lookup was built with </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.#ctor">
            <summary>
            Creates a new empty trie
            </summary>
            <seealso cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.Build(Lucene.Net.Search.Suggest.IInputEnumerator)"/>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.Add(System.String,System.Object)">
            <summary>
            Adds a new node if <code>key</code> already exists,
            otherwise replaces its value.
            <para>
            This method always returns false.
            </para>
            </summary>
            <param name="key"> A <see cref="T:System.String"/> index. </param>
            <param name="value"> The object to be stored in the Trie. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.Get(System.String)">
            <summary>
            Returns the value for the specified key, or null
            if the key does not exist.
            </summary>
            <param name="key"> A <see cref="T:System.String"/> index. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellLookup.GetSizeInBytes">
            <summary>
            Returns byte size of the underlying TST. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie">
            <summary>
            Implementation of a Ternary Search Trie, a data structure for storing
            <see cref="T:System.String"/>s that combines the compact size of a binary search
            tree with the speed of a digital search trie, and is therefore ideal for
            practical use in sorting and searching data.
            <para>
            
            This data structure is faster than hashing for many typical search problems,
            and supports a broader range of useful problems and operations. Ternary
            searches are faster than hashing and more powerful, too.
            </para>
            <para>
            
            The theory of ternary search trees was described at a symposium in 1997 (see
            "Fast Algorithms for Sorting and Searching Strings," by J.L. Bentley and R.
            Sedgewick, Proceedings of the 8th Annual ACM-SIAM Symposium on Discrete
            Algorithms, January 1997). Algorithms in C, Third Edition, by Robert
            Sedgewick (Addison-Wesley, 1998) provides yet another view of ternary search
            trees.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode">
            <summary>
            An inner class of Ternary Search Trie that represents a node in the trie.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.PARENT">
            <summary>
            Index values for accessing relatives array. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.LOKID">
            <summary>
            Index values for accessing relatives array. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.EQKID">
            <summary>
            Index values for accessing relatives array. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.HIKID">
            <summary>
            Index values for accessing relatives array. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.data">
            <summary>
            The key to the node. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.relatives">
            <summary>
            The relative nodes. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.splitchar">
            <summary>
            The char used in the split. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.#ctor(System.Char,Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Constructor method.
            </summary>
            <param name="splitchar">
                     The char used in the split. </param>
            <param name="parent">
                     The parent node. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode.GetSizeInBytes">
            <summary>
            Return an approximate memory usage for this node and its sub-nodes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.CompareCharsAlphabetically(System.Char,System.Char,System.Globalization.CultureInfo)">
            <summary>
            Compares characters by alfabetical order.
            </summary>
            <param name="cCompare2">
                     The first char in the comparison. </param>
            <param name="cRef">
                     The second char in the comparison. </param>
            <param name="culture">The culture used for lowercasing.</param>
            <returns> A negative number, 0 or a positive number if the second char is
                    less, equal or greater. </returns>
                    
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.defaultNumReturnValues">
            <summary>
            The default number of values returned by the <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/>
            method.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.matchAlmostDiff">
            <summary>
            the number of differences allowed in a call to the <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/>
            <c>key</c>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.rootNode">
            <summary>
            The base node in the trie. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor">
            <summary>
            Constructs an empty Ternary Search Trie.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Constructs an empty Ternary Search Trie,
            specifying the <see cref="T:System.Globalization.CultureInfo"/> used for lowercasing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor(System.IO.FileInfo)">
            <summary>
            Constructs a Ternary Search Trie and loads data from a <see cref="T:System.IO.FileInfo"/>
            into the Trie. The file is a normal text document, where each line is of
            the form word TAB float.
            
            <para>Uses the culture of the current thread to lowercase words before comparing.</para>
            </summary>
            <param name="file">
                     The <see cref="T:System.IO.FileInfo"/> with the data to load into the Trie. </param>
            <exception cref="T:System.IO.IOException">
                         A problem occured while reading the data. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor(System.IO.FileInfo,System.Globalization.CultureInfo)">
            <summary>
            Constructs a Ternary Search Trie and loads data from a <see cref="T:System.IO.FileInfo"/>
            into the Trie. The file is a normal text document, where each line is of
            the form word TAB float.
            
            <para>Uses the supplied culture to lowercase words before comparing.</para>
            </summary>
            <param name="file">
                     The <see cref="T:System.IO.FileInfo"/> with the data to load into the Trie. </param>
            <param name="culture">The culture used for lowercasing.</param>
            <exception cref="T:System.IO.IOException">
                         A problem occured while reading the data. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>
            Constructs a Ternary Search Trie and loads data from a <see cref="T:System.IO.FileInfo"/>
            into the Trie. The file is a normal text document, where each line is of
            the form "word TAB float".
            
            <para>Uses the culture of the current thread to lowercase words before comparing.</para>
            </summary>
            <param name="file">
                     The <see cref="T:System.IO.FileInfo"/> with the data to load into the Trie. </param>
            <param name="compression">
                     If true, the file is compressed with the GZIP algorithm, and if
                     false, the file is a normal text document. </param>
            <exception cref="T:System.IO.IOException">
                         A problem occured while reading the data. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.#ctor(System.IO.FileInfo,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Constructs a Ternary Search Trie and loads data from a <see cref="T:System.IO.FileInfo"/>
            into the Trie. The file is a normal text document, where each line is of
            the form "word TAB float".
            
            <para>Uses the supplied culture to lowercase words before comparing.</para>
            </summary>
            <param name="file">
                     The <see cref="T:System.IO.FileInfo"/> with the data to load into the Trie. </param>
            <param name="compression">
                     If true, the file is compressed with the GZIP algorithm, and if
                     false, the file is a normal text document. </param>
            <param name="culture">The culture used for lowercasing.</param>
            <exception cref="T:System.IO.IOException">
                         A problem occured while reading the data. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.DeleteNode(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Deletes the node passed in as an argument. If this node has non-null data,
            then both the node and the data will be deleted. It also deletes any other
            nodes in the trie that are no longer needed after the deletion of the node.
            </summary>
            <param name="nodeToDelete"> The node to delete. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.DeleteNodeRecursion(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Recursively visits each node to be deleted.
            
            To delete a node, first set its data to null, then pass it into this
            method, then pass the node returned by this method into this method (make
            sure you don't delete the data of any of the nodes returned from this
            method!) and continue in this fashion until the node returned by this
            method is <c>null</c>.
            
            The TSTNode instance returned by this method will be next node to be
            operated on by <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.DeleteNodeRecursion(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)"/> (This emulates recursive
            method call while avoiding the overhead normally associated with a
            recursive method.)
            </summary>
            <param name="currentNode"> The node to delete. </param>
            <returns> The next node to be called in deleteNodeRecursion. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.Get(System.String)">
            <summary>
            Retrieve the object indexed by a key.
            </summary>
            <param name="key"> A <see cref="T:System.String"/> index. </param>
            <returns> The object retrieved from the Ternary Search Trie. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetAndIncrement(System.String)">
            <summary>
            Retrieve the <see cref="T:float?"/> indexed by key, increment it by one unit
            and store the new <see cref="T:float?"/>.
            </summary>
            <param name="key"> A <see cref="T:System.String"/> index. </param>
            <returns> The <see cref="T:float?"/> retrieved from the Ternary Search Trie. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetKey(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Returns the key that indexes the node argument.
            </summary>
            <param name="node">
                     The node whose index is to be calculated. </param>
            <returns> The <see cref="T:System.String"/> that indexes the node argument. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetNode(System.String)">
            <summary>
            Returns the node indexed by key, or <c>null</c> if that node doesn't
            exist. Search begins at root node.
            </summary>
            <param name="key">
                     A <see cref="T:System.String"/> that indexes the node that is returned. </param>
            <returns> The node object indexed by key. This object is an instance of an
                    inner class named <see cref="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetNode(System.String,Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Returns the node indexed by key, or <c>null</c> if that node doesn't
            exist. The search begins at root node.
            </summary>
            <param name="key">
                     A <see cref="T:System.String"/> that indexes the node that is returned. </param>
            <param name="startNode">
                     The top node defining the subtrie to be searched. </param>
            <returns> The node object indexed by key. This object is an instance of an
                    inner class named <see cref="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetOrCreateNode(System.String)">
            <summary>
            Returns the node indexed by key, creating that node if it doesn't exist,
            and creating any required intermediate nodes if they don't exist.
            </summary>
            <param name="key">
                     A <see cref="T:System.String"/> that indexes the node that is returned. </param>
            <returns> The node object indexed by key. This object is an instance of an
                    inner class named <see cref="T:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode"/>. </returns>
            <exception cref="T:System.ArgumentNullException">
                         If the key is <c>null</c>. </exception>
            <exception cref="T:System.ArgumentException">
                         If the key is an empty <see cref="T:System.String"/>. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String)">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of keys that almost match the argument key.
            Keys returned will have exactly diff characters that do not match the
            target key, where diff is equal to the last value set
            to the <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> property.
            <para>
            If the <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/> method is called before the
            <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> property has been called for the first time,
            then diff = 0.
            
            </para>
            </summary>
            <param name="key">
                     The target key. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.IList`1"/> of keys that almost match the argument key.
            Keys returned will have exactly diff characters that do not match the
            target key, where diff is equal to the last value set
            to the <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> property.
            <para>
            If the <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/> method is called before the
            <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> property has been called for the first time,
            then diff = 0.
            
            </para>
            </summary>
            <param name="key"> The target key. </param>
            <param name="numReturnValues"> The maximum number of values returned by this method. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostRecursion(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode,System.Int32,System.Int32,System.String,System.Int32,System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>
            Recursivelly vists the nodes in order to find the ones that almost match a
            given key.
            </summary>
            <param name="currentNode">
                     The current node. </param>
            <param name="charIndex">
                     The current char. </param>
            <param name="d">
                     The number of differences so far. </param>
            <param name="matchAlmostNumReturnValues">
                     The maximum number of values in the result <see cref="T:System.Collections.Generic.List`1"/>. </param>
            <param name="matchAlmostResult2">
                     The results so far. </param>
            <param name="upTo">
                     If true all keys having up to and including <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> 
                     mismatched letters will be included in the result (including a key
                     that is exactly the same as the target string) otherwise keys will
                     be included in the result only if they have exactly
                     <see cref="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff"/> number of mismatched letters. </param>
            <param name="matchAlmostKey">
                     The key being searched. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchPrefix(System.String)">
            <summary>
            Returns an alphabetical <see cref="T:System.Collections.Generic.IList`1"/> of all keys in the trie that
            begin with a given prefix. Only keys for nodes having non-null data are
            included in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="prefix"> Each key returned from this method will begin with the characters
                     in prefix. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchPrefix(System.String,System.Int32)">
            <summary>
            Returns an alphabetical <see cref="T:System.Collections.Generic.IList`1"/> of all keys in the trie that
            begin with a given prefix. Only keys for nodes having non-null data are
            included in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="prefix"> Each key returned from this method will begin with the characters
                     in prefix. </param>
            <param name="numReturnValues"> The maximum number of values returned from this method. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.NumDataNodes">
            <summary>
            Returns the number of nodes in the trie that have non-null data.
            </summary>
            <returns> The number of nodes in the trie that have non-null data. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.NumDataNodes(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Returns the number of nodes in the subtrie below and including the starting
            node. The method counts only nodes that have non-null data.
            </summary>
            <param name="startingNode">
                     The top node of the subtrie. the node that defines the subtrie. </param>
            <returns> The total number of nodes in the subtrie. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.NumNodes">
            <summary>
            Returns the total number of nodes in the trie. The method counts nodes
            whether or not they have data.
            </summary>
            <returns> The total number of nodes in the trie. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.NumNodes(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode)">
            <summary>
            Returns the total number of nodes in the subtrie below and including the
            starting Node. The method counts nodes whether or not they have data.
            </summary>
            <param name="startingNode">
                     The top node of the subtrie. The node that defines the subtrie. </param>
            <returns> The total number of nodes in the subtrie. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.Put(System.String,System.Object)">
            <summary>
            Stores a value in the trie. The value may be retrieved using the key.
            </summary>
            <param name="key"> A <see cref="T:System.String"/> that indexes the object to be stored. </param>
            <param name="value"> The object to be stored in the Trie. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.RecursiveNodeCalculator(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode,System.Boolean,System.Int32)">
            <summary>
            Recursivelly visists each node to calculate the number of nodes.
            </summary>
            <param name="currentNode">
                     The current node. </param>
            <param name="checkData">
                     If true we check the data to be different of <c>null</c>. </param>
            <param name="numNodes2">
                     The number of nodes so far. </param>
            <returns> The number of nodes accounted. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.Remove(System.String)">
            <summary>
            Removes the value indexed by key. Also removes all nodes that are rendered
            unnecessary by the removal of this data.
            </summary>
            <param name="key"> A <see cref="T:System.String"/> that indexes the object to be removed from
                     the Trie. </param>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmostDiff">
            <summary>
            Sets the number of characters by which words can differ from target word
            when calling the <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/> method.
            <para>
            Arguments less than 0 will set the char difference to 0, and arguments
            greater than 3 will set the char difference to 3.
            
            </para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.NumReturnValues">
            <summary>
            Sets the default maximum number of values returned from the
            <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchPrefix(System.String,System.Int32)"/> and <see cref="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.MatchAlmost(System.String,System.Int32)"/> methods.
            <para>
            The value should be set this to -1 to get an unlimited number of return
            values. note that the methods mentioned above provide overloaded versions
            that allow you to specify the maximum number of return values, in which
            case this value is temporarily overridden.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.SortKeys(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode,System.Int32)">
            <summary>
            Returns keys sorted in alphabetical order. This includes the start Node and
            all nodes connected to the start Node.
            <para>
            The number of keys returned is limited to numReturnValues. To get a list
            that isn't limited in size, set numReturnValues to -1.
            
            </para>
            </summary>
            <param name="startNode">
                     The top node defining the subtrie to be searched. </param>
            <param name="numReturnValues">
                     The maximum number of values returned from this method. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.SortKeysRecursion(Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.TSTNode,System.Int32,System.Collections.Generic.IList{System.String})">
            <summary>
            Returns keys sorted in alphabetical order. This includes the current Node
            and all nodes connected to the current Node.
            <para>
            Sorted keys will be appended to the end of the resulting <see cref="T:System.Collections.Generic.List`1"/>.
            The result may be empty when this method is invoked, but may not be
            <c>null</c>.
            
            </para>
            </summary>
            <param name="currentNode">
                     The current node. </param>
            <param name="sortKeysNumReturnValues">
                     The maximum number of values in the result. </param>
            <param name="sortKeysResult2">
                     The results so far. </param>
            <returns> A <see cref="T:System.Collections.Generic.IList`1"/> with the results. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Jaspell.JaspellTernarySearchTrie.GetSizeInBytes">
            <summary>
            Return an approximate memory usage for this trie.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Lookup">
            <summary>
            Simple Lookup interface for <see cref="T:System.String"/> suggestions.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Lookup.LookupResult">
            <summary>
            Result of a lookup.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.Key">
            <summary>
            the key's text </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.HighlightKey">
            <summary>
            Expert: custom Object to hold the result of a
            highlighted suggestion. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.Value">
            <summary>
            the key's weight </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.Payload">
            <summary>
            the key's payload (null if not present) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.LookupResult.Contexts">
            <summary>
            the key's contexts (null if not present) </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Int64)">
            <summary>
            Create a new result from a key+weight pair.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Int64,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new result from a key+weight+payload triple.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Object,System.Int64,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new result from a key+highlightKey+weight+payload triple.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Int64,Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Create a new result from a key+weight+payload+contexts triple.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Int64,System.Collections.Generic.ISet{Lucene.Net.Util.BytesRef})">
            <summary>
            Create a new result from a key+weight+contexts triple.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.#ctor(System.String,System.Object,System.Int64,Lucene.Net.Util.BytesRef,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Create a new result from a key+highlightKey+weight+payload+contexts triple.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupResult.CompareTo(Lucene.Net.Search.Suggest.Lookup.LookupResult)">
            <summary>
            Compare alphabetically. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Lookup.CHARSEQUENCE_COMPARER">
            <summary>
            A simple char-by-char comparer for <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Lookup.LookupPriorityQueue">
            <summary>
            A <see cref="T:Lucene.Net.Util.PriorityQueue`1"/> collecting a fixed size of high priority <see cref="T:Lucene.Net.Search.Suggest.Lookup.LookupResult"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupPriorityQueue.#ctor(System.Int32)">
            <summary>
            Creates a new priority queue of the specified size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.LookupPriorityQueue.GetResults">
            <summary>
            Returns the top N results in descending order. </summary>
            <returns> the top N results in descending order. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass 
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Build(Lucene.Net.Search.Spell.IDictionary)">
            <summary>
            Build lookup from a dictionary. Some implementations may require sorted
            or unsorted keys from the dictionary's iterator - use
            <see cref="T:Lucene.Net.Search.Suggest.SortedInputEnumerator"/> or
            <see cref="T:Lucene.Net.Search.Suggest.UnsortedInputEnumerator"/> in such case.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Load(System.IO.Stream)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Suggest.Lookup.Load(Lucene.Net.Store.DataInput)"/> after converting
            <see cref="T:System.IO.Stream"/> to <see cref="T:Lucene.Net.Store.DataInput"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Store(System.IO.Stream)">
            <summary>
            Calls <see cref="M:Lucene.Net.Search.Suggest.Lookup.Store(Lucene.Net.Store.DataOutput)"/> after converting
            <see cref="T:System.IO.Stream"/> to <see cref="T:Lucene.Net.Store.DataOutput"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Suggest.Lookup.Count">
            <summary>
            Get the number of entries the lookup was built with </summary>
            <returns> total number of suggester entries </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Build(Lucene.Net.Search.Suggest.IInputEnumerator)">
            <summary>
            Builds up a new internal <see cref="T:Lucene.Net.Search.Suggest.Lookup"/> representation based on the given <see cref="T:Lucene.Net.Search.Suggest.IInputEnumerator"/>.
            The implementation might re-sort the data internally.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.DoLookup(System.String,System.Boolean,System.Int32)">
            <summary>
            Look up a key and return possible completion for this key. </summary>
            <param name="key"> lookup key. Depending on the implementation this may be
            a prefix, misspelling, or even infix. </param>
            <param name="onlyMorePopular"> return only more popular results </param>
            <param name="num"> maximum number of results to return </param>
            <returns> a list of possible completions, with their relative weight (e.g. popularity) </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.DoLookup(System.String,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Boolean,System.Int32)">
            <summary>
            Look up a key and return possible completion for this key. </summary>
            <param name="key"> lookup key. Depending on the implementation this may be
            a prefix, misspelling, or even infix. </param>
            <param name="contexts"> contexts to filter the lookup by, or null if all contexts are allowed; if the suggestion contains any of the contexts, it's a match </param>
            <param name="onlyMorePopular"> return only more popular results </param>
            <param name="num"> maximum number of results to return </param>
            <returns> a list of possible completions, with their relative weight (e.g. popularity) </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Store(Lucene.Net.Store.DataOutput)">
            <summary>
            Persist the constructed lookup data to a directory. Optional operation. </summary>
            <param name="output"> <see cref="T:Lucene.Net.Store.DataOutput"/> to write the data to. </param>
            <returns> true if successful, false if unsuccessful or not supported. </returns>
            <exception cref="T:System.IO.IOException"> when fatal IO error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.Load(Lucene.Net.Store.DataInput)">
            <summary>
            Discard current lookup data and load it from a previously saved copy.
            Optional operation. </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Store.DataInput"/> to load the lookup data. </param>
            <returns> true if completed successfully, false if unsuccessful or not supported. </returns>
            <exception cref="T:System.IO.IOException"> when fatal IO error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Lookup.GetSizeInBytes">
            <summary>
            Get the size of the underlying lookup implementation in memory </summary>
            <returns> ram size of the lookup implementation in bytes </returns>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.SortedInputEnumerator">
            <summary>
            This wrapper buffers incoming elements and makes sure they are sorted based on given comparer.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.#ctor(Lucene.Net.Search.Suggest.IInputEnumerator)">
            <summary>
            Creates a new sorted wrapper, using <see cref="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUnicodeComparer"/>
            for sorting. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.#ctor(Lucene.Net.Search.Suggest.IInputEnumerator,System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Creates a new sorted wrapper, sorting by BytesRef
            (ascending) then cost (ascending).
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.SortedInputEnumerator.tieBreakByCostComparer">
            <summary>
            Sortes by BytesRef (ascending) then cost (ascending). </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.Encode(Lucene.Net.Util.OfflineSorter.ByteSequencesWriter,Lucene.Net.Store.ByteArrayDataOutput,System.Byte[],Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef},System.Int64)">
            <summary>
            encodes an entry (bytes+(contexts)+(payload)+weight) to the provided writer
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.Decode(Lucene.Net.Util.BytesRef,Lucene.Net.Store.ByteArrayDataInput)">
            <summary>
            decodes the weight at the current position </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.DecodeContexts(Lucene.Net.Util.BytesRef,Lucene.Net.Store.ByteArrayDataInput)">
            <summary>
            decodes the contexts at the current position </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedInputEnumerator.DecodePayload(Lucene.Net.Util.BytesRef,Lucene.Net.Store.ByteArrayDataInput)">
            <summary>
            decodes the payload at the current position
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper">
            <summary>
            This wrapper buffers incoming elements and makes sure they are sorted based on given comparer.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper.#ctor(Lucene.Net.Search.Spell.ITermFreqEnumerator)">
            <summary>
            Creates a new sorted wrapper, using <see cref="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUnicodeComparer"/>
            for sorting. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper.#ctor(Lucene.Net.Search.Spell.ITermFreqEnumerator,System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Creates a new sorted wrapper, sorting by BytesRef
            (ascending) then cost (ascending).
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper.tieBreakByCostComparer">
            <summary>
            Sortes by BytesRef (ascending) then cost (ascending).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper.Encode(Lucene.Net.Util.OfflineSorter.ByteSequencesWriter,Lucene.Net.Store.ByteArrayDataOutput,System.Byte[],Lucene.Net.Util.BytesRef,System.Int64)">
            <summary>
            encodes an entry (bytes+weight) to the provided writer
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.SortedTermFreqEnumeratorWrapper.Decode(Lucene.Net.Util.BytesRef,Lucene.Net.Store.ByteArrayDataInput)">
            <summary>
            decodes the weight at the current position </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode">
            <summary>
            The class creates a TST node.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.#ctor">
            <summary>
            Creates a new empty node </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.splitchar">
            <summary>
            the character stored by a node. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.loKid">
            <summary>
            a reference object to the node containing character smaller than this node's character. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.eqKid">
            <summary>
             a reference object to the node containing character next to this node's character as 
             occurring in the inserted token.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.hiKid">
            <summary>
            a reference object to the node containing character higher than this node's character. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode.token">
            <summary>
            used by leaf nodes to store the complete tokens to be added to suggest list while 
            auto-completing the prefix.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Tst.TSTAutocomplete">
            <summary>
            Ternary Search Trie implementation.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Tst.TernaryTreeNode"/>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTAutocomplete.BalancedTree(System.Object[],System.Object[],System.Int32,System.Int32,Lucene.Net.Search.Suggest.Tst.TernaryTreeNode)">
            <summary>
            Inserting keys in TST in the order middle,small,big (lexicographic measure)
            recursively creates a balanced tree which reduces insertion and search
            times significantly.
            </summary>
            <param name="tokens">
                     Sorted list of keys to be inserted in TST. </param>
            <param name="lo">
                     stores the lower index of current list. </param>
            <param name="hi">
                     stores the higher index of current list. </param>
            <param name="root">
                     a reference object to root of TST. </param>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTAutocomplete.Insert(Lucene.Net.Search.Suggest.Tst.TernaryTreeNode,System.String,System.Object,System.Int32)">
            <summary>
            Inserts a key in TST creating a series of Binary Search Trees at each node.
            The key is actually stored across the eqKid of each node in a successive
            manner.
            </summary>
            <param name="currentNode">
                     a reference node where the insertion will take currently. </param>
            <param name="s">
                     key to be inserted in TST. </param>
            <param name="x">
                     index of character in key to be inserted currently. </param>
            <returns> The new reference to root node of TST </returns>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTAutocomplete.PrefixCompletion(Lucene.Net.Search.Suggest.Tst.TernaryTreeNode,System.String,System.Int32)">
            <summary>
            Auto-completes a given prefix query using Depth-First Search with the end
            of prefix as source node each time finding a new leaf to get a complete key
            to be added in the suggest list.
            </summary>
            <param name="root">
                     a reference to root node of TST. </param>
            <param name="s">
                     prefix query to be auto-completed. </param>
            <param name="x">
                     index of current character to be searched while traversing through
                     the prefix in TST. </param>
            <returns> suggest list of auto-completed keys for the given prefix query. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.Tst.TSTLookup">
            <summary>
            Suggest implementation based on a 
            <a href="http://en.wikipedia.org/wiki/Ternary_search_tree">Ternary Search Tree</a>
            </summary>
            <seealso cref="T:Lucene.Net.Search.Suggest.Tst.TSTAutocomplete"/>
        </member>
        <member name="F:Lucene.Net.Search.Suggest.Tst.TSTLookup.count">
            <summary>
            Number of entries the lookup was built with
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTLookup.#ctor">
            <summary>
            Creates a new TSTLookup with an empty Ternary Search Tree. </summary>
            <seealso cref="M:Lucene.Net.Search.Suggest.Tst.TSTLookup.Build(Lucene.Net.Search.Suggest.IInputEnumerator)"/>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTLookup.Add(System.String,System.Object)">
            <summary>
            Adds a new node if <code>key</code> already exists,
            otherwise replaces its value.
            <para>
            This method always returns true.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTLookup.Get(System.String)">
            <summary>
            Returns the value for the specified key, or null
            if the key does not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.Tst.TSTLookup.GetSizeInBytes">
            <summary>
            Returns byte size of the underlying TST
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Suggest.UnsortedInputEnumerator">
            <summary>
            This wrapper buffers the incoming elements and makes sure they are in
            random order.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Suggest.UnsortedInputEnumerator.#ctor(Lucene.Net.Search.Suggest.IInputEnumerator)">
            <summary>
            Creates a new iterator, wrapping the specified iterator and
            returning elements in a random order.
            </summary>
        </member>
    </members>
</doc>
